# 1751. Maximum Number of Events That Can Be Attended II

#### [link](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)

#### Description
You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.

You can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.

Return *the **maximum sum** of values that you can receive by attending events*.

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60048-pm.png)
```
Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
Output: 7
Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60150-pm.png)
```
Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
Output: 10
Explanation: Choose event 2 for a total value of 10.
Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.
```
#### Example 3:
![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60703-pm.png)
```
Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
Output: 9
Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.
```

#### Constraints:
* `1 <= k <= events.length`
* `1 <= k * events.length <= 10^6`
* `1 <= startDayi <= endDayi <= 10^9`
* `1 <= valuei <= 10^6`

## DFS + Memoization
```python
class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        memo = [[ 0 for _ in range(k + 1)] for _ in range(len(events))]
        events.sort()

        return self.__cal(0, k, events, memo)

    def __cal(self, now, k, events, memo):
        if k == 0 or now == len(events):
            return 0

        if memo[now][k] != 0:
            return memo[now][k]
        
        # skip now
        skip_now = self.__cal(now + 1, k, events, memo)
        # select now
        _, now_end, now_val = events[now]
        next_idx = self.__binary_search_right(events, now_end)
        select_now = now_val + self.__cal(next_idx, k - 1, events, memo)
        
        memo[now][k] = max(skip_now, select_now)
        return memo[now][k]
        
    def __binary_search_right(self, events, target):
        left, right = 0, len(events)
        while left < right:
            mid = left + (right - left) // 2
            if events[mid][0] > target:
                right = mid
            elif events[mid][0] <= target:
                left = mid + 1

        return left
```
### Time complexity
* O(n * k * logn)
* n: len(events)
### Space complexity
* O(n * k)
### Remark
* Use binary search to efficiently find the next non-overlapping interval

## DFS + Memoization (binary search optimized)
```python
class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        memo = [[ 0 for _ in range(k + 1)] for _ in range(len(events))]
        events.sort()
        next_index = [-1] * len(events)
        for i in range(len(events)):
            next_index[i] = self.__binary_search_right(events, events[i][1])

        return self.__cal(0, k, events, next_index, memo)

    def __cal(self, now, k, events, next_index, memo):
        if k == 0 or now == len(events):
            return 0

        if memo[now][k] != 0:
            return memo[now][k]
        
        # skip now
        skip_now = self.__cal(now + 1, k, events, next_index, memo)
        # select now
        select_now = events[now][2] + self.__cal(next_index[now], k - 1, events, next_index, memo)
        
        memo[now][k] = max(skip_now, select_now)
        return memo[now][k]
        
    def __binary_search_right(self, events, target):
        left, right = 0, len(events)
        while left < right:
            mid = left + (right - left) // 2
            if events[mid][0] > target:
                right = mid
            elif events[mid][0] <= target:
                left = mid + 1

        return left
```
### Time complexity
* O(n * (k + logn))
* n: len(events)
### Space complexity
* O(n * k)

## Dynamic Programming
```python
class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        n = len(events)
        dp = [[ 0 for _ in range(k + 1)] for _ in range(n + 1)]
        events.sort()
        event_starts = [event[0] for event in events]

        for i in range(n - 1, -1, -1):
            for j in range(1, k + 1):
                skip_now = dp[i + 1][j]
                select_now = events[i][2] + dp[bisect.bisect_right(event_starts, events[i][1])][j - 1]
                dp[i][j] = max(select_now, skip_now)

        return dp[0][k]
```
### Time complexity
* O(n * k * logn)
* n: len(events)
### Space complexity
* O(n * k)

## Dynamic Programming (binary search optimized)
```python
class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        n = len(events)
        dp = [[ 0 for _ in range(k + 1)] for _ in range(n + 1)]
        events.sort()
        event_starts = [event[0] for event in events]

        for i in range(n - 1, -1, -1):
            next_idx = bisect.bisect_right(event_starts, events[i][1])
            for j in range(1, k + 1):
                skip_now = dp[i + 1][j]
                select_now = events[i][2] + dp[next_idx][j - 1]
                dp[i][j] = max(select_now, skip_now)

        return dp[0][k]
```
### Time complexity
* O(n * (k + logn))
* n: len(events)
### Space complexity
* O(n * k)
### Remark
* Brilliant! Avoid replicated binary search with O(1) space