# 212. Word Search II

#### [link](https://leetcode.com/problems/word-search-ii/)

#### Description
Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*.

Each word must be constructed from letters of sequentially **adjacent cells**, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

#### Example 1:
![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)
```
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)
```
Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
```

#### Constraints:
* `m == board.length`
* `n == board[i].length`
* `1 <= m, n <= 12`
* `board[i][j]` is a lowercase English letter.
* `1 <= words.length <= 3 * 10^4`
* `1 <= words[i].length <= 10`
* `words[i]` consists of lowercase English letters.
* All the strings of `words` are unique.

## Trie + BackTracking
```java
class Solution {
    int[][] NEIGHBOR = {{1, 0},{-1, 0},{0, 1},{0, -1}};
    
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        buildTrie(words, root);
        List<String> ans = new ArrayList<>();
        
        for(int i = 0 ; i < board.length ; i++){
            for(int j = 0 ; j < board[0].length ; j++){
                dfs(ans, board, root, i, j);
            }
        }
        
        return ans;
    }
    
    private void dfs(List<String> ans, char[][] board, TrieNode now, int i, int j){
        if(board[i][j] == '#' || now.next[board[i][j] - 'a'] == null)
            return;
            
        now = now.next[board[i][j] - 'a'];
        char c = board[i][j];
        board[i][j] = '#';
        if(now.word != null){
            ans.add(now.word);
            now.word = null;
        }
        for(int[] n : NEIGHBOR){
            int newI = i + n[0];
            int newJ = j + n[1];
            if(newI < 0 || newI >= board.length || newJ < 0 || newJ >= board[0].length){
                continue;
            }
            dfs(ans, board, now, newI, newJ);
        }
        board[i][j] = c;
    }
    
    private void buildTrie(String[] words, TrieNode root){
        for(String word : words){
            TrieNode now = root;
            for(char c : word.toCharArray()){
                if(now.next[c - 'a'] == null){
                    now.next[c - 'a'] = new TrieNode();
                }
                now = now.next[c - 'a'];
            }
            now.word = word;
        }
    }
    
    class TrieNode{
        String word;
        TrieNode[] next;
        
        public TrieNode(){
            next = new TrieNode[26];
        }
    }
}
```
### Time Complexity
* O(M*N * 3^LEN) ,LEN is the longest word's length
### Space Complexity
* O(K * LEN), Trie. 
* K: number of words ; the worst case is that there are no common prefix between each word.
### Remark
* If we repreat the 079 for each word, it will cause a lot of time as well as duplicate looking up.
* By using trie, when finding a path, we are also finding the word in the trie, it will effectely reduce the overhead.
* The most magical improvement is that, the time complexity is similar as onle the one word. However it still need some time to build trie.
* To remove duplicate, just set the s to be null so that it will never be valid, awesome!

## Trie + BackTracking (python)
```python
class TrieNode:
    def __init__(self):
        self.next = {}
        self.end_word = False

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        m, n = len(board), len(board[0])
        
        root = TrieNode()
        for word in words:
            now = root
            for c in word:
                if c not in now.next:
                    now.next[c] = TrieNode()
                now = now.next[c]
            now.end_word = True

        ans = []
        for i in range(m):
            for j in range(n):
                self.__dfs(i, j, root, board, [], ans)

        return ans

    def __dfs(self, i, j, now, board, word_arr, ans):
        if now.end_word:
            now.end_word = False
            ans.append("".join(word_arr))

        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]):
            return
        if board[i][j] not in now.next:
            return

        offsets = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        c = board[i][j]
        word_arr.append(c)
        board[i][j] = "*"
        for x, y in offsets:
            self.__dfs(i + x, j + y, now.next[c], board, word_arr, ans)
        board[i][j] = word_arr.pop()

        if not now.next[c].next:
            del now.next[c]
```
### Time Complexity
* O(MN * 3^(longest word len))
### Space Complexity
* O((all word characters)+(longest word len))
### Remark
* We can prune the leaf nodes to optimize
* Mark end word to false to ensure no duplication