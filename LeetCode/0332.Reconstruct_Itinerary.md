# 332. Reconstruct Itinerary

#### [link](https://leetcode.com/problems/reconstruct-itinerary/)

#### Description
You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

All of the tickets belong to a man who departs from `"JFK"`, thus, the itinerary must begin with "JFK". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

* For example, the itinerary `["JFK", "LGA"]` has a smaller lexical order than `["JFK", "LGB"]`.

You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)
```
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)
```
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.
```

#### Constraints:
* `1 <= tickets.length <= 300`
* `tickets[i].length == 2`
* `fromi.length == 3`
* `toi.length == 3`
* `fromi` and `toi` consist of uppercase English letters.
* `fromi` != `toi`

## DFS
```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Collections.sort(tickets, (a, b) -> (a.get(0).equals(b.get(0)) ? a.get(1).compareTo(b.get(1)) : a.get(0).compareTo(b.get(0))));
        Map<String, List<String>> graph = new HashMap<>();
        
        for(List<String> ticket : tickets){
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.putIfAbsent(from, new ArrayList<>());
            graph.get(from).add(to);
        }
        
        List<String> ans = dfs("JFK", graph, new HashMap<>(), tickets.size() + 1);
    
        return ans;
    }
    
    private List<String> dfs(String now, Map<String, List<String>> graph, Map<String, Set<Integer>> used, int n){
        List<String> ans = new ArrayList<>();
        ans.add(now);
        if(n == 1){
            return ans;
        }
        if(graph.containsKey(now)){
            int idx = 0;
            for(String next : graph.get(now)){
                if(used.getOrDefault(now, new HashSet<>()).contains(idx)){
                    idx++;
                    continue;
                }
                used.putIfAbsent(now, new HashSet<>());
                used.get(now).add(idx);
                List<String> nextList = dfs(next, graph, used, n - 1);
                used.get(now).remove(idx);
                if(nextList != null){
                    ans.addAll(nextList);
                    return ans;
                }
                idx++;
            }
        }
        return null;
    }
}
```
### Time complexity
* O(n!)
### Space complexity
* O(n)
### Remark

## Eulerian path
```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, PriorityQueue<String>> graph = new HashMap<>();
        List<String> ans = new LinkedList<>();
        
        for(List<String> ticket : tickets){
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.putIfAbsent(from, new PriorityQueue<>());
            graph.get(from).offer(to);
        }
    
        compute(ans, graph, "JFK");
        return ans;
    }
    
    private void compute(List<String> ans, Map<String, PriorityQueue<String>> graph, String now){
        PriorityQueue<String> nextQueue = graph.getOrDefault(now, new PriorityQueue<>());
        while(!nextQueue.isEmpty()){
            String next = nextQueue.poll();
            compute(ans, graph, next);
        }
        ans.add(0, now);
    }
}
```
### Time complexity
* O()
### Space complexity
* O(n)
### Remark
* Brilliant!
* 一筆畫問題

## Eulerian path (python)
```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        tickets.sort()
        graph = {}
        for _from, _to in tickets:
            if _from not in graph:
                graph[_from] = deque()
            graph[_from].append(_to)

        path = []
        self._find("JFK", graph, path)
        return path[::-1]

    def _find(self, now, graph, path):
        while now in graph and graph[now]:
            next = graph[now].popleft()
            self._find(next, graph, path)

        path.append(now)
```
### Time complexity
* O(ElogE)
### Space complexity
* O(E)
### Remark
* starting point: indegree + 1 = outdegree
* ending point: indegree = outdegree + 1
* other point: indegree == outdegree
* keep poping the edges as recursion goes.
* construct path reversely