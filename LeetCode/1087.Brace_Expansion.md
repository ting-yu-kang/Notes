# 1087. Brace Expansion

#### [link](https://leetcode.com/problems/brace-expansion/)

#### Description
You are given a string 1 representing a list of words. Each letter in the word has one or more options.

* If there is one option, the letter is represented as is.
* If there is more than one option, then curly braces delimit the options. For example, `"{a,b,c}"` represents options `["a", "b", "c"]`.

For example, if `s = "a{b,c}"`, the first character is always `'a'`, but the second character can be `'b'` or `'c'`. The original list is `["ab", "ac"]`.

Return all words that can be formed in this manner, **sorted** in lexicographical order.

#### Example 1:
```
Input: s = "{a,b}c{d,e}f"
Output: ["acdf","acef","bcdf","bcef"]
```
#### Example 2:
```
Input: s = "abcd"
Output: ["abcd"]
```

#### Constraints:
* `1 <= s.length <= 50`
* `s` consists of curly brackets `'{}'`, commas `','`, and lowercase English letters.
* `s` is guaranteed to be a valid input.
* There are no nested curly brackets.
* All characters inside a pair of consecutive opening and ending curly brackets are different.

## Recursion
```python
class Solution:
    def expand(self, s: str) -> List[str]:
        ans = [""]
        return sorted(self._expand(s, 0))

    def _expand(self, s, now):
        if now == len(s):
            return [""]

        if s[now] == "{":
            right = s.find("}", now + 1)
            str_list = self._expand(s, right + 1)
            options = s[now + 1: right].split(",")
        else:
            str_list = self._expand(s, now + 1)
            options = [s[now]]

        str_list_new = []
        for str_now in str_list:
            for option in options:
                str_list_new.append(option + str_now)
        return str_list_new
```
### Time complexity
* O()
### Space complexity
* O()
### Remark
* return array of string from the end

## Iteration
```python
class Solution:
    def expand(self, s: str) -> List[str]:
        ans = [""]
        i = 0
        while i < len(s):
            left = s.find("{", i)
            if left == -1:
                tmp = []
                for str_now in ans:
                    tmp.append(str_now + s[i:])
                i = len(s)
            else:
                right = s.find("}", left + 1)
                options = s[left + 1 : right].split(",")
                tmp = []
                for str_now in ans:
                    for option in options:
                        tmp.append(str_now + s[i : left] + option)
                i = right + 1
            ans = tmp

        return sorted(ans)
```
### Time complexity
* O()
### Space complexity
* O()
### Remark
* append from the array of string from the start

## Backtracking
```python
class Solution:
    def expand(self, s: str) -> List[str]:
        ans = []
        self._backtrack(0, s, "", ans)
        return sorted(ans)

    def _backtrack(self, now, s, str_now, ans):
        if now == len(s):
            ans.append(str_now)
            return

        left = s.find("{", now)
        if left == -1:
            ans.append(str_now + s[now:])
        else:
            right = s.find("}", left + 1)
            options = s[left + 1 : right].split(",")
            for option in options:
                tmp = str_now
                str_now += s[now : left] + option
                self._backtrack(right + 1, s, str_now, ans)
                str_now = tmp
```
### Time complexity
* O()
### Space complexity
* O()
### Remark
* try different combinations