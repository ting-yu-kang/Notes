# 1604. Alert Using Same Key-Card Three or More Times in a One Hour Period

#### [link](https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/)

#### Description
LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an **alert** if any worker uses the key-card **three or more times** in a one-hour period.

You are given a list of strings `keyName` and `keyTime` where `[keyName[i], keyTime[i]]` corresponds to a person's name and the time when their key-card was used **in a single day**.

Access times are given in the **24-hour time format "HH:MM"**, such as `"23:51"` and `"09:49"`.

Return *a list of unique worker names who received an alert for frequent keycard use.* Sort the names in **ascending order alphabetically**.

Notice that `"10:00"` - `"11:00"` is considered to be within a one-hour period, while `"22:51"` - `"23:52"` is not considered to be within a one-hour period.

#### Example 1:
```
Input: keyName = ["daniel","daniel","daniel","luis","luis","luis","luis"], keyTime = ["10:00","10:40","11:00","09:00","11:00","13:00","15:00"]
Output: ["daniel"]
Explanation: "daniel" used the keycard 3 times in a one-hour period ("10:00","10:40", "11:00").
```
#### Example 2:
```
Input: keyName = ["alice","alice","alice","bob","bob","bob","bob"], keyTime = ["12:01","12:00","18:00","21:00","21:20","21:30","23:00"]
Output: ["bob"]
Explanation: "bob" used the keycard 3 times in a one-hour period ("21:00","21:20", "21:30").
```

#### Constraints:
* `1 <= keyName.length, keyTime.length <= 10^5`
* `keyName.length == keyTime.length`
* `keyTime[i]` is in the format **"HH:MM"**.
* `[keyName[i], keyTime[i]]` is **unique**.
* `1 <= keyName[i].length <= 10`
* `keyName[i] contains only lowercase English letters.`

## HashMap + Sliding Window
```python
class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        n = len(keyName)
        alert_names = []
        access_record = {}
        for name, time in zip(keyName, keyTime):
            if name not in access_record:
                access_record[name] = []
            access_record[name].append(self.__time_to_minute(time))

        for name, times in access_record.items():
            times.sort()
            for i in range(len(times) - 2):
                if times[i] + 60 >= times[i + 2]:
                    alert_names.append(name)
                    break

        alert_names.sort()
        return alert_names
                
    
    def __time_to_minute(self, time):
        hour, minute = map(int, time.split(":"))
        return hour * 60 + minute
```
### Time complexity
* O(nlogn) for each name
### Space complexity
* O(n), hashmap
### Remark