# 474. Ones and Zeroes

#### [link](https://leetcode.com/problems/ones-and-zeroes/) 

#### Description
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.

For now, suppose you are a dominator of **m** `0s` and **n** `1s` respectively. On the other hand, there is an array with strings consisting of only `0s` and `1s`.

Now your task is to find the maximum number of strings that you can form with given **m** `0s` and **n** `1s`. Each `0` and `1` can be used at most once.

#### Note:
1. The given numbers of `0s` and `1s` will both not exceed `100`
2. The size of given string array won't exceed `600`.

#### Example 1:
```
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”
```
#### Example 2:
```
Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
```

## Dynamic Programming
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        
        for(String now : strs){
            int zeros = count(now)[0];
            int ones = count(now)[1];
            for(int i = m ; i >= zeros ; i--){
                for(int j = n ; j >= ones ; j--){
                        dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        return dp[m][n];
    }

    private int[] count(String s){
        int[] ret = new int[2];
        for(char now : s.toCharArray()){
            if(now == '0')
                ret[0]++;
            else
                ret[1]++;
        }
        return ret;
    }
}
```

### Time complexity
* O(|strs| * m * n)
### Space complexity
* O(m * n)
### Remark
* Knapsack problem
* Non-duplicate => from last to first