# 695. Max Area of Island

#### [link](https://leetcode.com/problems/max-area-of-island/)

#### Description
You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The **area** of an island is the number of cells with a value `1` in the island.

Return *the maximum **area** of an island in grid*. If there is no island, return `0`.

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)
```
Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
```
#### Example 2:
```
Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
```

#### Constraints:
* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 50`
* `grid[i][j]` is either `0` or `1`.

## DFS
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        max_area = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    max_area = max(max_area, self.__dfs(i, j, grid))
        return max_area

    def __dfs(self, i, j, grid):
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            return 0
        if grid[i][j] != 1:
            return 0
        grid[i][j] = 2
        area = 1
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        for x, y in directions:
            area += self.__dfs(i + x, j + y, grid)

        return area
```
### Time complexity
* O(m * n)
### Space complexity
* O(m * n)
### Remark