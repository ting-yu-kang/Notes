# 272. Closest Binary Search Tree Value II

#### [link](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) 

#### Description
Given the `root` of a binary search tree, a `target` value, and an integer `k`, return *the `k` values in the BST that are closest to the `target`*. You may return the answer in **any order**.

You are **guaranteed** to have only one unique set of `k values in the BST that are closest to the `target`.

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg)
```
Input: root = [4,2,5,1,3], target = 3.714286, k = 2
Output: [4,3]
```
#### Example 2:
```
Input: root = [1], target = 0.000000, k = 1
Output: [1]
```

#### Constraints:

The number of nodes in the tree is `n`.
* `1 <= k <= n <= 10^4`.
* `0 <= Node.val <= 10^9`
* `-10*9 <= target <= 10^9`
 

#### Follow up: 
Assume that the BST is balanced. Could you solve it in less than `O(n)` runtime (where `n = total nodes`)?

## Iteration 1
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode prev, next;
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        TreeNode now = root;
        List<Integer> ans = new ArrayList<>();
        Deque<Integer> preStack = new ArrayDeque<>();
        Deque<Integer> nextStack = new ArrayDeque<>();
        createPreStack(preStack, target, root);
        createNextStack(nextStack, target, root);
        if(!preStack.isEmpty() && !nextStack.isEmpty() && preStack.getFirst() == nextStack.getFirst()){
            preStack.removeFirst();
        }
        while(ans.size() < k){
            if(preStack.isEmpty()){
                ans.add(nextStack.removeFirst());
            }
            else if(nextStack.isEmpty()){
                ans.add(preStack.removeFirst());
            }
            else{
                if(Math.abs(preStack.getFirst() - target) < Math.abs(nextStack.getFirst() - target)){
                    ans.add(preStack.removeFirst());
                }
                else{
                    ans.add(nextStack.removeFirst());
                }
            }
        }
        return ans;
    }
    
    private void createPreStack(Deque<Integer> preStack, double target, TreeNode root){
        Deque<TreeNode> tmpStack = new ArrayDeque<>();
        while(root != null || !tmpStack.isEmpty()){
            while(root != null){
                tmpStack.addFirst(root);
                root = root.left;
            }
            root = tmpStack.removeFirst();
            if(root.val > target)
                return;
            preStack.addFirst(root.val);
            root = root.right;
        }
    }
    
    private void createNextStack(Deque<Integer> nextStack, double target, TreeNode root){
        Deque<TreeNode> tmpStack = new ArrayDeque<>();
        while(root != null || !tmpStack.isEmpty()){
            while(root != null){
                tmpStack.addFirst(root);
                root = root.right;
            }
            root = tmpStack.removeFirst();
            if(root.val < target)
                return;
            nextStack.addFirst(root.val);
            root = root.left;
        }
    }
}
```
### Time complexity
* O(n + k)
### Space complexity
* O(n)
### Remark
* Use two stacks to store inorder and reverse inorder.

## Iteration 2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        if(root == null)
            throw new IllegalArgumentException();
            
        List<Integer> flatten = new ArrayList<>();
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode now = root;
        
        while(!stack.isEmpty() || now != null){
            while(now != null){
                stack.addFirst(now);
                now = now.left;
            }
            now = stack.removeFirst();
            flatten.add(now.val);
            now = now.right;
        }
        
        int find = 0;
        for(; find < flatten.size() ; find++){
            if(flatten.get(find) >= target)
                break;
        }
        
        int left = find - 1;
        int right = find;
        while(ans.size() < k){
            if(left < 0)
                ans.add(flatten.get(right++));
            else if(right >= flatten.size())
                ans.add(flatten.get(left--));
            else{
                double leftDiff = target - flatten.get(left);
                double rightDiff = flatten.get(right) - target;
                if(leftDiff < rightDiff)
                    ans.add(flatten.get(left--));
                else
                    ans.add(flatten.get(right++));
            }
        }
        return ans;
    }
}
```
### Time complexity
* O(n + k)
### Space complexity
* O(n)
### Remark
* Flatten the tree and find k nearest neighbor

## Iteration 3
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode prev, next;
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        if(root == null)
            throw new IllegalArgumentException();
            
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> preStack = new ArrayDeque<>();
        Deque<TreeNode> nextStack = new ArrayDeque<>();
        buildStacks(preStack, nextStack, root, target);

        if(preStack.size() > 0 && nextStack.size() > 0 && preStack.getFirst() == nextStack.getFirst())         {
            moveNext(nextStack);
        }
        
        while(ans.size() < k){
            if(preStack.isEmpty()){
                ans.add(nextStack.getFirst().val);
                moveNext(nextStack);
            }
            else if(nextStack.isEmpty()){
                ans.add(preStack.getFirst().val);
                movePre(preStack);
            }
            else{
                double diffLeft = target - preStack.getFirst().val;
                double diffRight = nextStack.getFirst().val - target;
                if(diffLeft <= diffRight){
                    ans.add(preStack.getFirst().val);
                    movePre(preStack);
                }
                else{
                    ans.add(nextStack.getFirst().val);
                    moveNext(nextStack);
                }
            }
        }
        
        return ans;
    }
    
    private void buildStacks(Deque<TreeNode> preStack, 
                             Deque<TreeNode> nextStack, 
                             TreeNode root, 
                             double target){
        while(root != null){
            if(target < root.val){
                nextStack.addFirst(root);
                root = root.left;
            }
            else if(target > root.val){
                preStack.addFirst(root);
                root = root.right;
            }
            else{
                nextStack.addFirst(root);
                preStack.addFirst(root);
                break;
            }
        }
    }
    
    private void moveNext(Deque<TreeNode> nextStack){
        TreeNode now = nextStack.removeFirst();
        if(now.right == null)
            return;
        
        now = now.right;
        while(now != null){
            nextStack.addFirst(now);
            now = now.left;
        }
    }
    
    private void movePre(Deque<TreeNode> preStack){
        TreeNode now = preStack.removeFirst();
        if(now.left == null)
            return;
        
        now = now.left;
        while(now != null){
            preStack.addFirst(now);
            now = now.right;
        }
    }
}
```
### Time complexity
* O(log(n) + k) = O(H + k)
### Space complexity
* O(log(n)) = O(H)
### Remark
* best solution
* Use two stacks to store pres and nexts. O(H)
* get k nearest, avg operation: O(1)

## DFS + deque (python)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -> List[int]:
        queue = deque()
        self.dfs(root, target, k, queue)
        return list(queue)

    def dfs(self, now, target, k, queue):
        if not now:
            return
        
        self.dfs(now.left, target, k, queue)
        if len(queue) < k:
            queue.append(now.val)
        else:
            if abs(queue[0] - target) <= abs(now.val - target):
                return
            queue.popleft()
            queue.append(now.val)
        self.dfs(now.right, target, k, queue)
```
### Time Complexity:
* O(n)
### Space Complexity:
* O(n + k)

### Remark
* Early end and easy to track
* There are better solutions like targeting the node and keep finding prev/next. Check them out if having time.