# 253. Meeting Rooms II

#### [link](https://leetcode.com/problems/meeting-rooms-ii/)

#### Description
Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return *the minimum number of conference rooms required*.

#### Example 1:
```
Input: [[0, 30],[5, 10],[15, 20]]
Output: 2
```
#### Example 2:
```
Input: [[7,10],[2,4]]
Output: 1
```

#### Constraints:
* `1 <= intervals.length <= 10^4`
* `0 <= starti < endi <= 10^6`

## Priority Queue
```java
class Solution {
    public int minMeetingRooms(Interval[] intervals) {
        if(intervals == null || intervals.length == 0) return 0; 
        int len = intervals.length;
        
        Arrays.sort(intervals, (a, b) -> a.start - b.start);
        PriorityQueue<Interval> PQ = new PriorityQueue<>((a, b) -> a.end - b.end);
        PQ.offer(intervals[0]);
        
        for(int i = 1 ; i < len ; i++){
            if(intervals[i].start >= PQ.peek().end)
                PQ.poll();
            PQ.offer(intervals[i]);
        }
        
        return PQ.size();
    }
}
```
### Time complexity
* O(NlogN), sort + heapify
### Space complexity
* O(n), PriorityQueue
### Remark
* more intuitive, the elements in PQ represent the rooms being used.

## Two pointer
```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        int n = intervals.length;
        int[] start = new int[n];
        int[] end = new int[n];
        
        int idx = 0;
        for(int[] now : intervals){
            start[idx] = now[0];
            end[idx] = now[1];
            idx++;
        }
        Arrays.sort(start);
        Arrays.sort(end);
        
        int count = 0;
        int maxCount = 0;
        
        for(int i = 0, j = 0 ; i < n ; i++){
            //close a room
            if(start[i] >= end[j]){
                count--;
                j++;
            }
            //open a room
            count++;
            maxCount = Math.max(maxCount, count);
        }
        
        return maxCount;
    }
}
```
### Time Complexity
* O(NlogN), sort
### Space Complexity
* O(N), Start and End array
### Remark
* Brilliant! Use to pointer to solve this problem
* same logic as priority queue approach

## Sort + Heap (Python)
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        end_times = []
        for start, end in intervals:
            if end_times and end_times[0] <= start:
                heapq.heappop(end_times)
            heapq.heappush(end_times, end)

        return len(end_times)
```
### Time complexity
* O(NlogN)
### Space complexity
* O(N)

## Two Pointers (python)
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        start_times = sorted([interval[0] for interval in intervals])
        end_times = sorted([interval[1] for interval in intervals])

        start_idx = 0
        end_idx = 0
        room_count = 0
        while start_idx < n:
            if start_times[start_idx] >= end_times[end_idx]:
                room_count -= 1
                end_idx += 1
            room_count += 1
            start_idx += 1

        return room_count
```
### Time complexity
* O(NlogN)
### Space complexity
* O(N)
### Remark
* It's cool. Sort start and end separately

