# 381. Insert Delete GetRandom O(1) - Duplicates allowed

#### [link](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

#### Description
`RandomizedCollection` is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.

Implement the `RandomizedCollection` class:

* `RandomizedCollection()` Initializes the empty `RandomizedCollection` object.
* `bool insert(int val)` Inserts an item val into the multiset, even if the item is already present. Returns `true` if the item is not present, `false` otherwise.
* `bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item is present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.
* `int getRandom()` Returns a random element from the current multiset of elements. The probability of each element being returned is **linearly related** to the number of the same values the multiset contains.

You must implement the functions of the class such that each function works on **average** `O(1)` time complexity.

**Note:** The test cases are generated such that `getRandom` will only be called if there is **at least one** item in the `RandomizedCollection`.

#### Example:
```
Input
["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]

Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return true since the collection does not contain 1.
                                  // Inserts 1 into the collection.
randomizedCollection.insert(1);   // return false since the collection contains 1.
                                  // Inserts another 1 into the collection. Collection now contains [1,1].
randomizedCollection.insert(2);   // return true since the collection does not contain 2.
                                  // Inserts 2 into the collection. Collection now contains [1,1,2].
randomizedCollection.getRandom(); // getRandom should:
                                  // - return 1 with probability 2/3, or
                                  // - return 2 with probability 1/3.
randomizedCollection.remove(1);   // return true since the collection contains 1.
                                  // Removes 1 from the collection. Collection now contains [1,2].
randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.
```

#### Constraints:
* `-2^31 <= val <= 2^31 - 1`
* At most `2 * 10^5` calls **in total** will be made to `insert`, `remove`, and `getRandom`.
* There will be **at least one** element in the data structure when `getRandom` is called.

## HashMap + ArrayList
```java
class RandomizedCollection {
    Map<Integer, Set<Integer>> valToIdxSet;
    List<Integer> values;
    Random rand;
    
    /** Initialize your data structure here. */
    public RandomizedCollection() {
        valToIdxSet = new HashMap<>();
        values = new ArrayList<>();
        rand = new Random();
    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    public boolean insert(int val) {
        boolean ret = false;
        if(!valToIdxSet.containsKey(val)){
            valToIdxSet.put(val, new HashSet<>());
            ret = true;
        }
        values.add(val);
        valToIdxSet.get(val).add(values.size() - 1);
        
        return ret;
    }
    
    // targetIdx ..... lastIdx
    // val             lastVal
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    public boolean remove(int val) {        
        if(!valToIdxSet.containsKey(val)){
            return false;
        }
        int targetIdx = valToIdxSet.get(val).iterator().next();
        int lastIdx = values.size() - 1;
        int lastVal = values.get(lastIdx);
        
        if(lastVal == val){
            valToIdxSet.get(val).remove(lastIdx);
            values.remove(lastIdx);
        }
        else{
            //move element from last to target
            values.set(targetIdx, lastVal);
            valToIdxSet.get(lastVal).remove(lastIdx);
            valToIdxSet.get(lastVal).add(targetIdx);
            valToIdxSet.get(val).remove(targetIdx);

            //remove last element;
            values.remove(lastIdx);
        }
        if(valToIdxSet.get(val).size() == 0)
            valToIdxSet.remove(val);
        
        return true;
    }
    
    /** Get a random element from the collection. */
    public int getRandom() {
        int randomNum = rand.nextInt(values.size());
        return values.get(randomNum);
    }
}

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection obj = new RandomizedCollection();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```
### Time complexity
* insert: O(1)
* remove: O(1)
* getRandom: O(1)
### Space complexity
* O(n)
### Remark
* map value to set of indices
* must handle if the delete value is equal to the last element

## HashMap with List (python)
```python
class RandomizedCollection:

    def __init__(self):
        self.list = []
        self.map = {}

    def insert(self, val: int) -> bool:
        self.list.append(val)
        idx = len(self.list) - 1
        if val in self.map:
            self.map[val].add(idx)
            return False
        self.map[val] = set([idx])
        return True

    def remove(self, val: int) -> bool:
        if not val in self.map:
            return False

        idx = self.map[val].pop()
        if not self.map[val]:
            del self.map[val]

        if idx < len(self.list) - 1:
            last = self.list[len(self.list) - 1]
            self.list[idx] = last
            self.map[last].remove(len(self.list) - 1)
            self.map[last].add(idx)

        self.list.pop()
        return True

    def getRandom(self) -> int:
        return random.choice(self.list)


# Your RandomizedCollection object will be instantiated and called as such:
# obj = RandomizedCollection()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```
### Time complexity
* insert: O(1)
* remove: O(1)
* getRandom: O(1)
### Space complexity
* O(n)
### Remark
* Use map with set to record the element location
* Just swap the removed element with the last one to achieve O(1)