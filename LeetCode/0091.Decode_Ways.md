# 91. Decode Ways

#### [link](https://leetcode.com/problems/decode-ways/)

#### Description
You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:

`"1" -> 'A'`

`"2" -> 'B'`

`...`

`"25" -> 'Y'`

`"26" -> 'Z'`

However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (`"2"` and `"5"` vs `"25"`).

For example, `"11106"` can be decoded into:

* `"AAJF"` with the grouping `(1, 1, 10, 6)`
* `"KJF"` with the grouping `(11, 10, 6)`
* The grouping `(1, 11, 06)` is invalid because `"06"` is not a valid code (only `"6"` is valid).

Note: there may be strings that are impossible to decode.

Given a string s containing only digits, return the **number of ways** to **decode** it. If the entire string cannot be decoded in any valid way, return `0`.

The test cases are generated so that the answer fits in a **32-bit** integer.

#### Example 1:
```
Input: s = "12"

Output: 2

Explanation:

"12" could be decoded as "AB" (1 2) or "L" (12).
```
#### Example 2:
```
Input: s = "226"

Output: 3

Explanation:

"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```
#### Example 3:
```
Input: s = "06"

Output: 0

Explanation:

"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.
```

#### Constraints:
* `1 <= s.length <= 100`
* `s` contains only digits and may contain leading zero(s).

## Dynamic Programming
```java
class Solution {
    public int numDecodings(String s) {
        if(s == null || s.length() == 0)
            return 0;

        int[] dp = new int[s.length()];
        for(int i = 0 ; i < s.length() ; i++){
            if(s.charAt(i) != '0'){
                if(i == 0){
                    dp[i] += 1;
                }
                else{
                    dp[i] += dp[i - 1];
                }
            }
            
            if(i == 0)
                continue;

            int num = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');
            if(10 <= num && num <= 26){
                if(i == 1){
                    dp[i] += 1;
                }
                else{
                    dp[i] += dp[i - 2];
                }
            }
        }
        return dp[s.length() - 1];
    }
}
```
### Time complexity
* O(n)
### Space complexity
* O(n)
### Remark

## DFS + Memo (python)
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        self.numbers = set([str(i) for i in range(1, 27)])
        self.memo = [-1] * len(s)
        return self.__cal(0, s)

    def __cal(self, now, s):
        if now == len(s):
            return 1

        if self.memo[now] != -1:
            return self.memo[now]

        ans = 0
        if s[now] in self.numbers:
            ans += self.__cal(now + 1, s)
        if now + 1 < len(s) and s[now : now + 2] in self.numbers:
            ans += self.__cal(now + 2, s)

        self.memo[now] = ans
        return ans
```
### Time complexity
* O(n)
### Space complexity
* O(n)

## Dynamic Programming bottom up (python)
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        numbers = set([str(i) for i in range(1, 27)])
        dp = [0] * (len(s) + 1)
        dp[len(s)] = 1

        for i in range(len(s) - 1, -1, -1):
            if s[i] in numbers:
                dp[i] += dp[i + 1]
            if i + 1 < len(s) and s[i : i + 2] in numbers:
                dp[i] += dp[i + 2]

        return dp[0]
```
### Time complexity
* O(n)
### Space complexity
* O(n)

## Dynamic Programming optimized (python)
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        numbers = set([str(i) for i in range(1, 27)])
        dp = [0] * (len(s) + 1)
        dp[len(s)] = 1

        # a0, a1, a2
        a1 = 1
        a2 = 0
        for i in range(len(s) - 1, -1, -1):
            a0 = 0
            if s[i] in numbers:
                a0 += a1
            if i + 1 < len(s) and s[i : i + 2] in numbers:
                a0 += a2
            a1, a2 = a0, a1

        return a1
```
### Time complexity
* O(n)
### Space complexity
* O(1)