# 1135. Connecting Cities With Minimum Cost

#### [link](https://leetcode.com/problems/connecting-cities-with-minimum-cost/)

#### Description
There are `n` cities labeled from `1` to `n`. You are given the integer `n` and an array `connections` where `connections[i] = [xi, yi, costi]` indicates that the cost of connecting city `xi` and city `yi` (bidirectional connection) is `costi`.

Return *the minimum **cost** to connect all the `n` cities such that there is at least one path between each pair of cities*. If it is impossible to connect all the `n` cities, return `-1`,

The **cost** is the sum of the connections' costs used.

#### Example 1:
![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex2.png)
```
Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
Output: 6
Explanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex1.png)
```
Input: n = 4, connections = [[1,2,3],[3,4,4]]
Output: -1
Explanation: There is no way to connect all cities even if all edges are used.
```

#### Constraints:
* `1 <= n <= 10^4`
* `1 <= connections.length <= 10^4`
* `connections[i].length == 3`
* `1 <= xi, yi <= n`
* `xi != yi`
* `0 <= costi <= 10^5`

## Minimum Spanning Tree + Union Find
```python
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.weights = [1] * n
        self.groups = n

    def union(self, a, b):
        parent_a = self.find(a)
        parent_b = self.find(b)
        if parent_a == parent_b:
            return
        
        if self.weights[parent_a] < self.weights[parent_b]:
            self.parent[parent_a] = parent_b
            self.weights[parent_b] += self.weights[parent_a]
        else:
            self.parent[parent_b] = parent_a
            self.weights[parent_a] += self.weights[parent_b]
        
        self.groups -= 1

    def find(self, a):
        if self.parent[a] != a:
            self.parent[a] = self.find(self.parent[a])

        return self.parent[a]

class Solution:
    def minimumCost(self, n: int, connections: List[List[int]]) -> int:
        connections.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        min_cost = 0
        for a, b, cost in connections:
            if uf.find(a - 1) == uf.find(b - 1):
                continue
            uf.union(a - 1, b - 1)
            min_cost += cost

        return min_cost if uf.groups == 1 else -1
```
### Time complexity
* m: number of connections
* O(mlogm)
* sort: O(mlogm)
* find: O(mlogn) ~= O(m)
### Space complexity
* O(n)
### Remark