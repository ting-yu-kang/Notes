# 787. Cheapest Flights Within K Stops

#### [link](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

#### Description
There are `n` cities connected by `m` flights. Each fight starts from city `u` and arrives at `v` with a price `w`.

Now given all the cities and flights, together with starting city `src` and the destination `dst`, your task is to find the cheapest price from `src` to `dst` with up to `k` stops. If there is no such route, output `-1`.

#### Example 1:
```
Example 1:
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200
Explanation: 
The graph looks like this:
```
![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)
```
The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.
```
#### Example 2:
```
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
Output: 500
Explanation: 
The graph looks like this:
```
![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)
```
The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.
```

#### Note:
* The number of nodes n will be in range `[1, 100]`, with nodes labeled from `0` to `n - 1`.
* The size of `flights` will be in range `[0, n * (n - 1) / 2]`.
* The format of each flight will be `(src, dst, price)`.
* The price of each flight will be in the range `[1, 10000]`.
* k is in the range of `[0, n - 1]`.
* There will not be any duplicated flights or self cycles.

## Bellman–Ford
```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        K += 1;
        int[] minCosts = new int[n];
        int[] tmpCosts = new int[n];
        Arrays.fill(minCosts, Integer.MAX_VALUE / 2);
        Arrays.fill(tmpCosts, Integer.MAX_VALUE / 2);
        minCosts[src] = 0;
        tmpCosts[src] = 0;
        
        for(int i = 1 ; i <= K ; i++){
            for(int[] flight : flights){
                int s = flight[0];
                int t = flight[1];
                int w = flight[2];
                tmpCosts[t] = Math.min(minCosts[s] + w, tmpCosts[t]);
            }
            int[] arr = minCosts;
            minCosts = tmpCosts;
            tmpCosts = arr;
        }

        return minCosts[dst] == Integer.MAX_VALUE / 2 ? -1 : minCosts[dst];
    }
}
```
### Time Complexity
* O(K * E)
* E : edge(flights)
### Space Complexity
* O(n)
* n: nodes
### Remark
* Brillant! keep update the min distance step by step.
* This is actually Bellman–Ford Algorithm

## Dijkstra (wrong)
```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        K += 1;
        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        int[] minCosts = new int[n];
        int[] minSteps = new int[n];
        for(int i = 0 ; i < n ; i++){
            graph.put(i, new HashMap<>());
            minCosts[i] = Integer.MAX_VALUE;
            minSteps[i] = Integer.MAX_VALUE;
        }
        for(int[] flight : flights){
            graph.get(flight[0]).put(flight[1], flight[2]);
        }
        pq.offer(new int[]{src, 0, 0}); // id, cost, step
        
        while(!pq.isEmpty()){
            int[] now = pq.poll();
            int nowId = now[0];
            int nowCost = now[1];
            int nowStep = now[2];
            if(nowId == dst)
                return nowCost;
            if(nowStep == K)
                continue;
            for(Map.Entry<Integer, Integer> e : graph.get(nowId).entrySet()){
                int next = e.getKey();
                int edgeCost = e.getValue();
                int newCost = nowCost + edgeCost;
                int newStep = nowStep + 1;
                if(newCost < minCosts[next]){
                    minCosts[next] = newCost;
                    pq.offer(new int[]{next, newCost, newStep});
                }
                else if(newStep < minSteps[next]){
                    minSteps[next] = newStep;
                    pq.offer(new int[]{next, newCost, newStep});
                }
            }
        }
        
        return -1;
    }
}
```
### Time Complexity
* O(E+nlogn)
### Space Complexity
* O(n), priority queue
* It's not easy to estimate, cause same node could be added multiple times
### Remark
* use `newSteps` and `newCosts` arrays to add any possible nodes


## Priority Queue
```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        K += 1;
        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        for(int i = 0 ; i < n ; i++){
            graph.put(i, new HashMap<>());
        }
        for(int[] flight : flights){
            graph.get(flight[0]).put(flight[1], flight[2]);
        }
        pq.offer(new int[]{src, 0, 0}); // id, cost, step
        
        while(!pq.isEmpty()){
            int[] now = pq.poll();
            int nowId = now[0];
            int nowCost = now[1];
            int nowStep = now[2];
            if(nowId == dst)
                return nowCost;
            if(nowStep == K)
                continue;
            for(Map.Entry<Integer, Integer> e : graph.get(nowId).entrySet()){
                int next = e.getKey();
                int edgeCost = e.getValue();
                pq.offer(new int[]{next, nowCost + edgeCost, nowStep + 1});
            }
        }
        
        return -1;
    }
}
```
### Time Complexity
* O(E+BIGlogBIG)
### Space Complexity
* very big, containing duplicate node
* will timeout when there are cycles
* O(N^k)
### Remark
* It's not dijkstra

## Bellman–Ford (python)
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        min_cost = [sys.maxsize] * n
        min_cost[src] = 0

        for _ in range(min(n - 1, k + 1)):
            tmp_cost = min_cost.copy()
            for s, t, price in flights:
                tmp_cost[t] = min(tmp_cost[t], min_cost[s] + price)
            
            if min_cost == tmp_cost:
                break
            min_cost = tmp_cost

        return min_cost[dst] if min_cost[dst] != sys.maxsize else -1
```
### Time Complexity
* O(k * E)
### Space complexity
* O(V)
### Remark
* each round, switch min_cost with tmp_cost
* At most V-1 round to get the min_cost path

## BFS (python)
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = {}
        for s, t, p in flights:
            if s not in graph:
                graph[s] = []
            graph[s].append((t, p))

        queue = deque()
        queue.append((src, 0)) # id, cost
        min_cost = [sys.maxsize] * n
        
        for _ in range(k + 2):
            n = len(queue)
            for _ in range(n):
                now, now_cost = queue.popleft()
                if now_cost >= min_cost[now]:
                    continue
                min_cost[now] = now_cost
                if now not in graph:
                    continue
                for next, edge_cost in graph[now]:
                    next_cost = now_cost + edge_cost
                    queue.append((next, next_cost))

        return min_cost[dst] if min_cost[dst] != sys.maxsize else -1
```
### Time Complexity
* O(V + k * E)
### Space complexity
* O(V + k * E)
### Remark
* Avoid going through all edges all time. Only continue shorter cost nodes

## Dijkstra (python)
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = defaultdict(list)
        for _from, _to, price in flights:
            graph[_from].append((_to, price))

        min_step = [sys.maxsize] * n
        heap = [(0, 0, src)]
        heapq.heapify(heap)

        while heap:
            now_price, now_step, now = heapq.heappop(heap)
            if now == dst:
                return now_price
            if now_step >= min_step[now]:
                continue
            min_step[now] = now_step
            if now_step + 1 > k + 1:
                continue
            for next, next_price in graph[now]:
                heapq.heappush(heap, (now_price + next_price, now_step + 1, next))

        return -1
```
### Time Complexity
* O(k * E * (E + log(k * E)))
* k * E: elements in heap
* E: iterate next node
### Space complexity
* O(V + k * E)
### Remark
* with priority queue, if we see same node twice, the first one will be shorter cost.
* since we have max step cap, so we need to reconsider if the step is lesser even though the cost is higher
* without max step cap, we won't put the same node twice to the queue