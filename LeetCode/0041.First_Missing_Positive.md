# 41. First Missing Positive

#### [link](https://leetcode.com/problems/first-missing-positive/)

#### Description
Given an unsorted integer array `nums`. Return the smallest positive integer that is not present in `nums`.

You must implement an algorithm that runs in `O(n)` time and uses `O(1)` auxiliary space.

#### Example 1:
```
Input: nums = [1,2,0]
Output: 3
Explanation: The numbers in the range [1,2] are all in the array.
```
#### Example 2:
```
Input: nums = [3,4,-1,1]
Output: 2
Explanation: 1 is in the array but 2 is missing.
```
#### Example 3:
```
Input: nums = [7,8,9,11,12]
Output: 1
Explanation: The smallest positive integer 1 is missing.
```

#### Constraints:
* 1 <= nums.length <= 10^5
* -2^31 <= nums[i] <= 2^31 - 1

## Iteration
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums == null)
            return 1;
        
        int n = partition(nums);
        for(int i = 0 ; i < n ; i++){
            int now = Math.abs(nums[i]);
            if(now <= n){
                if(nums[now - 1] > 0)
                    nums[now - 1] = 0 - nums[now - 1];
            }
        }
        for(int i = 0 ; i < n ; i++){
            if(nums[i] > 0)
                return i + 1;
        }
        return n + 1;
    }
    
    private int partition(int[] nums){
        int count = 0;
        for(int i = 0 ; i < nums.length ; i++){
            if(nums[i] > 0){
                swap(nums, i, count);
                count++;
            }
        }
        return count;
    }
    
    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```
### Time complexity
* O(n)
### Space complexity
* O(1)
### Remark
* Tricky, first aggregate the positive elements to the left. Then use positive/negative trick to record the element encountered. At last, iterate through the array to find the first positive number.

## Sort
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = partition(nums);
        Arrays.sort(nums, 0, n);
        int now = 0;
        for(int i = 0 ; i < n ; i++){
            if(nums[i] == now + 1)
                now++;
            else if(nums[i] != now)
                return now + 1;
        }
        return now + 1;
    }
    
    private int partition(int[] nums){
        int count = 0;
        for(int i = 0 ; i < nums.length ; i++){
            if(nums[i] > 0){
                swap(nums, i, count);
                count++;
            }
        }
        return count;
    }
    
    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```
### Time complexity
* O(nlog(n))
### Space complexity
* O(1)

## Negative as Seen
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        contains_1 = False
        for i in range(len(nums)):
            if nums[i] == 1:
                contains_1 = True
            if nums[i] > n or nums[i] < 1:
                nums[i] = 1

        if not contains_1:
            return 1

        for i in range(len(nums)):
            val = abs(nums[i])
            if val < n:
                nums[val] = -abs(nums[val])
            if val == n:
                nums[0] = -abs(nums[0])

        for i in range(2, len(nums)):
            if nums[i] > 0:
                return i
        
        if nums[0] > 0:
            return n
        
        return n + 1
```
### Time complexity
* O(n)
### Space complexity
* O(1)
### Remark
* Tricky
* Mark non candidate as 1
* Use negative trick to mark seen element
* The first positive element is the answer

## Cycle Sort
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        i = 0
        while i < n:
            correct_idx = nums[i] - 1
            if 0 <= correct_idx < n and nums[i] != nums[correct_idx]:
                nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
            else:
                i += 1

        for i in range(n):
            if nums[i] != i + 1:
                return i + 1

        return n + 1
```
### Time complexity
* O(n)
### Space complexity
* O(1)
### Remark
* Brilliant