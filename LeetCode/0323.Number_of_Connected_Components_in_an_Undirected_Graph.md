# 323. Number of Connected Components in an Undirected Graph

## Also
[LintCode 431](../LintCode/431.Connected_Component_in_Undirected_Graph.md)

#### [link](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

#### Description
You have a graph of `n` nodes. You are given an integer n and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.

Return *the number of connected components in the graph.*

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/03/14/conn1-graph.jpg)
```
Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2021/03/14/conn2-graph.jpg)
```
Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]
Output: 1
```

#### Constraints:
* `1 <= n <= 2000`
* `1 <= edges.length <= 5000`
* `edges[i].length == 2`
* `0 <= ai <= bi < n`
* `ai != bi`
* There are no repeated edges.

## BFS
```java
class Solution {
    public int countComponents(int n, int[][] edges) {
        boolean[] visited = new boolean[n];
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        int component = 0;
        for(int node = 0 ; node < n ; node++)
            graph.put(node, new HashSet<>());
        for(int[] edge : edges){
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        for(int node = 0 ; node < n ; node++){
            if(visited[node])
                continue;
            component++;
            bfs(node, graph, visited);
        }
        
        return component;
    }
    
    private void bfs(int node, Map<Integer, Set<Integer>> graph, boolean[] visited){
        Deque<Integer> queue = new ArrayDeque<>();
        queue.add(node);
        visited[node] = true;
        while(!queue.isEmpty()){
            int now = queue.removeFirst();
            for(int next : graph.get(now)){
                if(visited[next])
                    continue;
                queue.addLast(next);
                visited[next] = true;
            }
        }
    }
}
```
### Time complexity
* O(V + E)
### Space complexity
* O(V + E)
### Remark

## DFS (python)
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = [[] for i in range(n)]
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        components = 0
        seen = [False] * n
        for i in range(n):
            if seen[i]:
                continue
            components += 1
            self.__dfs(i, graph, seen)

        return components

    def __dfs(self, now, graph, seen):
        seen[now] = True
        for next in graph[now]:
            if seen[next]:
                continue
            self.__dfs(next, graph, seen)
```
### Time complexity
* O(V + E)
### Space complexity
* O(V + E)
### Remark

## UnionFind (python)
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UnionFind(n)
        for a, b in edges:
            uf.union(a, b)

        return uf.components

class UnionFind:
    def __init__(self, n):
        self.parent = [ i for i in range(n) ]
        self.size = [ 1 for i in range(n) ]
        self.components = n

    def union(self, a, b):
        parent_a = self.find(a)
        parent_b = self.find(b)
        if parent_a == parent_b:
            return

        self.components -= 1
        size_a = self.size[parent_a]
        size_b = self.size[parent_b]
        if size_a < size_b:
            self.parent[parent_a] = parent_b
            self.size[parent_b] += self.size[parent_a]
        else:
            self.parent[parent_b] = parent_a
            self.size[parent_a] += self.size[parent_b]

    def find(self, a):
        if self.parent[a] != a:
            self.parent[a] = self.find(self.parent[a])

        return self.parent[a]
```
### Time complexity
* O(V + E * alpha(n)) ~= O(V + E)
### Space complexity
* O(V)
### Remark
* can either use rank or size