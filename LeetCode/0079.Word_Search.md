# 79. Word Search
#### [link](https://leetcode.com/problems/word-search/submissions/)

#### Description
Given an `m x n` grid of characters `board` and a string `word`, return *`true` if `word` exists in the grid*.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

#### Example 1:
![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)
```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)
```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
```
#### Example 3:
![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)
```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
```

#### Constraints:
* `m == board.length`
* `n = board[i].length`
* `1 <= m, n <= 6`
* `1 <= word.length <= 15`
* `board` and `word` consists of only lowercase and uppercase English letters.

**Follow up:** Could you use search pruning to make your solution faster with a larger board?

## Backtracking
```java
class Solution {
    int[][] NEIGHBORS = {{1, 0},{-1, 0},{0, 1},{0, -1}};
    
    public boolean exist(char[][] board, String word) {
        if(word == null || word.length() == 0)
            return false;
        
        for(int i = 0 ; i < board.length ; i++){
            for(int j = 0 ; j < board[0].length ; j++){
                if(dfs(board, i, j, word, 0))
                    return true;
            }
        }
        return false;
    }
    
    private boolean dfs(char[][] board, int i, int j, String word, int now){
        if(now == word.length())
            return true;
        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length)
            return false;
        if(word.charAt(now) != board[i][j])
            return false;
        
        char c = board[i][j];
        board[i][j] = '#';
        
        for(int[] n : NEIGHBORS){
            if(dfs(board, i + n[0], j + n[1], word, now + 1)){
                board[i][j] = c;
                return true;
            }
        }
            
        board[i][j] = c;
        return false;
    }
}
```
### Time complexity
* O(MN * 3^len), iterate through the cells and each cell will do at most 4^len search 
### Space complexity
* `O(LEN)` dfs function stack

## BackTracking (python)
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        m = len(board)
        n = len(board[0])
        if len(word) > m * n:
            return False
        
        for i in range(m):
            for j in range(n):
                if self.__dfs(i, j, 0, word, board):
                    return True

        return False

    def __dfs(self, i, j, now, word, board) -> bool:
        if now == len(word):
            return True
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] != word[now]:
            return False
        if board[i][j] != word[now]:
            return False

        board[i][j] = "*"
        offsets = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        for x, y in offsets:
            if self.__dfs(i + x, j + y, now + 1, word, board):
                board[i][j] = word[now]
                return True
        board[i][j] = word[now]
        return False
```
### Time complexity
* `O(MN * 3^len)`, iterate through the cells and each cell will go at most 3^len directions (not going back) 
### Space complexity
* `O(LEN)` dfs function stack