# 347. Top K Frequent Elements

#### [link](https://leetcode.com/problems/top-k-frequent-elements/)

#### Description
Given an integer array `nums` and an integer `k`, return *the `k` most frequent elements*. You may return the answer in **any order**.

#### Example 1:
```
Input: nums = [1,1,1,2,2,3], k = 2

Output: [1,2]
```
#### Example 2:
```
Input: nums = [1], k = 1

Output: [1]
```
#### Example 3:
```
Input: nums = [1,2,1,2,1,2,3,1,3,2], k = 2

Output: [1,2]
```

#### Constraints:
* `1 <= nums.length <= 10^5`
* `-10^4 <= nums[i] <= 10^4`
* `k` is in the range `[1, the number of unique elements in the array]`.
* It is **guaranteed** that the answer is **unique**.
 

**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.


## Priority Queue
```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> valToCount = new HashMap<>();
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> valToCount.get(a) - valToCount.get(b)); 
        List<Integer> ans = new ArrayList<>();
            
        for(int n : nums){
            valToCount.compute(n, (key, v) -> v == null ? 1 : v + 1);
        }
        
        for(int n : valToCount.keySet()){
            pq.offer(n);
            if(pq.size() > k)
                pq.poll();
        }
        
        while(!pq.isEmpty()){
            ans.add(pq.poll());
        }
        
        return ans;
    }
}
```
### Time complexity
* O(n + nlog(k))
### Space complexity
* O(n)
### Remark

## Bucket Sort
```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> valToCount = new HashMap<>();
        List<Integer>[] buckets = new List[nums.length + 1]; 
        List<Integer> ans = new ArrayList<>();
            
        for(int n : nums){
            valToCount.compute(n, (key, v) -> v == null ? 1 : v + 1);
        }
        
        for(Map.Entry<Integer, Integer> e : valToCount.entrySet()){
            int val = e.getKey();
            int count = e.getValue();
            if(buckets[count] == null){
                buckets[count] = new ArrayList<>();
            }
            buckets[e.getValue()].add(e.getKey());
        }
        
        for(int i = nums.length ; i >= 0 && ans.size() < k ; i--){
            if(buckets[i] != null){
                ans.addAll(buckets[i]);
            }
        }
        
        return ans.subList(0, k);
    }
}
```
### Time complexity
* O(n)
### Space complexity
* O(n)
### Remark

## Counter + Heap
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_count = {}
        for num in nums:
            num_count[num] = num_count.get(num, 0) + 1

        heap = []
        for num, count in num_count.items():    
            if len(heap) ==  k:
                if count > heap[0][0]:
                    heapq.heappop(heap)
                    heapq.heappush(heap, (count, num))
            else:
                heapq.heappush(heap, (count, num))

        return [val[1] for val in heap]
```
### Time complexity
* O(n + nlogk)
### Space complexity
* O(n + k)
### Remark

## Quick Select
potentially O(n)