# 146. LRU Cache

#### [link](https://leetcode.com/problems/lru-cache/solution/) 

#### Description
Design a data structure that follows the constraints of a **Least Recently Used (LRU) cache**.

Implement the `LRUCache` class:

* `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.
* `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.
* `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.
The functions `get` and `put` must each run in `O(1)` average time complexity.

#### Example 1:
```
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
```

#### Constraints
* `1 <= capacity <= 3000`
* `0 <= key <= 10^4`
* `0 <= value <= 10^5`
* At most `2 * 10^5` calls will be made to `get` and `put`.

## HashMap + Double LinkedList
```java
class LRUCache {
    int capacity;
    Map<Integer, Node> map = new HashMap<>();
    Node start;
    Node end;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.start = new Node(-1, -1);
        this.end = new Node(-1, -1);
        start.next = end;
        end.prev = start;
    }
    
    public int get(int key) {
        if(!map.containsKey(key))
            return -1;
        Node nowNode = map.get(key);
        remove(nowNode);
        add(nowNode);
        return nowNode.val;
    }
    
    public void put(int key, int value) {
        if(map.containsKey(key)){
            Node nowNode = map.get(key);
            nowNode.val = value;
            remove(nowNode);
            add(nowNode);
            return;
        }
        if(map.size() == capacity){
            Node removeNode = start.next;
            remove(removeNode);
            map.remove(removeNode.key);
        }
        Node nowNode = new Node(key, value);
        map.put(key, nowNode);
        add(nowNode);
    }
    
    // last -> end
    // last -> now -> end
    private void add(Node now){
        Node last = end.prev;
        last.next = now;
        now.prev = last;
        now.next = end;
        end.prev = now;
    }
    
    // prev -> now -> next
    // prev -> next
    private void remove(Node now){
        Node prev = now.prev;
        Node next = now.next;
        prev.next = next;
        next.prev = prev;
    }
    
    private class Node{
        int key;
        int val;
        Node prev;
        Node next;
        public Node(int k, int v){
            this.key = k;
            this.val = v;
        }
    }
    
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
 ### Time complexity
 * Put: O(1)
 * Get: O(1)
 ### Space complexity
 * O(n)
 ### Remark
 * Use double linkedlist and a hash map to implement it.
 * add: add the node to the last.
 * Remove: remove node.

 ## LinkedHashMap (Sorted Dictionary)
```java
class LRUCache {
    
    Map<Integer, Integer> map;
    int capacity;
    
    public LRUCache(int capacity) {
        map = new LinkedHashMap<>(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return map.getOrDefault(key, -1);
    }

    public void set(int key, int value) {
        if(!map.containsKey(key)){
            while(map.size() >= capacity){
                map.remove(map.entrySet().iterator().next().getKey());
            }
        }
        map.put(key, value);
    }
}
```
### Time complexity
* O(1)
### Space complexity
* O(C)
### Remark
* This is a sorted data structure.
* Indicating true let get method affect order as well.

## HashMap + Double Linked List
```python
class LRUCache:

    def __init__(self, capacity: int):
        self.start = Node(-1, -1)
        self.end = Node(-1, -1)
        self.start.next = self.end
        self.end.prev = self.start
        self.map = {}
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.map:
            return -1
        
        now = self.map[key]
        self.remove(now)
        self.append(now)

        return now.value

    def put(self, key: int, value: int) -> None:
        if key in self.map:
            node = self.map[key]
            node.value = value
            self.remove(node)
            self.append(node)
            return

        if self.size == self.capacity:
            del self.map[self.start.next.key]
            self.remove(self.start.next)
            self.size -= 1

        new_node = Node(key, value)
        self.append(new_node)
        self.map[key] = new_node
        self.size += 1

    def remove(self, node) -> None:
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node

    def append(self, node) -> None:
        prev_node = self.end.prev
        next_node = self.end
        prev_node.next = node
        node.next = next_node
        next_node.prev = node
        node.prev = prev_node
        

class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```
### Time complexity
* O(1)
### Space complexity
* O(C)