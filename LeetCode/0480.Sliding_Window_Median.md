# 480. Sliding Window Median

#### [link](https://leetcode.com/problems/sliding-window-median/)

#### Description
The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.

* For examples, if `arr = [2,3,4]`, the median is `3`.
* For examples, if `arr = [1,2,3,4]`, the median is `(2 + 3) / 2 = 2.5`.
You are given an integer array `nums` and an integer `k`. There is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the median array for each window in the original array. Answers within `10^-5` of the actual value will be accepted.

#### Example 1:
```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
Explanation: 
Window position                Median
---------------                -----
[1  3  -1] -3  5  3  6  7        1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7        3
 1  3  -1  -3 [5  3  6] 7        5
 1  3  -1  -3  5 [3  6  7]       6
```
#### Example 2:
```
Input: nums = [1,2,3,4,2,3,1,4,2], k = 3
Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]
```

#### Constraints:
* `1 <= k <= nums.length <= 10^5`
* `-2^31 <= nums[i] <= 2^31 - 1`

## Double Priority Queue
```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        PriorityQueue<Integer> left = new PriorityQueue<>((a, b) -> Integer.compare(b, a));
        PriorityQueue<Integer> right = new PriorityQueue<>((a, b) -> Integer.compare(a, b));
        int leftRemove = 0;
        int rightRemove = 0;
        Map<Integer, Integer> removed = new HashMap<>();
        double[] ans = new double[nums.length - k + 1];
        
        for(int i = 0 ; i < k ; i++){
            left.offer(nums[i]);
            right.offer(left.poll());
            if(right.size() > left.size()){
                left.offer(right.poll());
            }
        }
        
        ans[0] = getMedian(left, right, k);
        
        for(int i = k ; i < nums.length ; i++){
            left.offer(nums[i]);
            right.offer(left.poll());
            
            int removeElement = nums[i - k];
            
            // judge where is the removed element
            if(left.peek() == removeElement){
                left.poll();
            }
            else if(right.peek() == removeElement){
                right.poll();
            }
            else if(left.peek() > removeElement){
                removed.compute(removeElement, (key, v) -> v == null ? 1 : v + 1);
                leftRemove++;
            }
            else if(right.peek() < removeElement){
                removed.compute(removeElement, (key, v) -> v == null ? 1 : v + 1);
                rightRemove++;
            }
            
            int leftSize = left.size() - leftRemove;
            int rightSize = right.size() - rightRemove;
            
            // balance two priority queues
            if(rightSize > leftSize){
                if(removed.getOrDefault(right.peek(), 0) > 0){
                    removed.compute(right.peek(), (key, v) -> v - 1);
                    right.poll();
                    rightRemove--;
                }
                else{
                    left.offer(right.poll());
                    leftSize++;
                    rightSize--;
                }
            }
            
            // remove invalid elements
            while(removed.getOrDefault(right.peek(), 0) > 0){
                removed.compute(right.peek(), (key, v) -> v - 1);
                right.poll();
                rightRemove--;
            }
            while(removed.getOrDefault(left.peek(), 0) > 0){
                removed.compute(left.peek(), (key, v) -> v - 1);
                left.poll();
                leftRemove--;
            }
            
            ans[i - k + 1] = getMedian(left, right, k);
        }
        
        return ans;
    }
    
    private double getMedian(PriorityQueue<Integer> left, PriorityQueue<Integer> right, int k){
        if(k % 2 == 0)
            return (double) left.peek() / 2 + (double) right.peek() / 2;
        else
            return (double) left.peek();
    }
}
```
### Time complexity
* O(nlog(n))
### Space complexity
* O(n)
### Remark
* super hard

## Double Heap (python)
```python
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        self.left_heap = [] # max
        self.right_heap = [] # min
        self.left_removed_count = 0
        self.right_removed_count = 0
        self.removed_pending = defaultdict(int)

        for i in range(k):
            self.window_add(nums[i])

        ans = [self.get_medium()]
        for i in range(k, len(nums)):
            self.window_add(nums[i])
            self.window_remove(nums[i - k])
            ans.append(self.get_medium())

        return ans

    def window_add(self, val):
        if not self.left_heap or val <= -(self.left_heap[0]):
            heapq.heappush(self.left_heap, -val)
        else:
            heapq.heappush(self.right_heap, val)
        
        self.rebalance()

    def window_remove(self, val):
        if val == -self.left_heap[0]:
            heapq.heappop(self.left_heap)
            self.clean()
        elif val == self.right_heap[0]:
            heapq.heappop(self.right_heap)
            self.clean()
        else:
            if val < -self.left_heap[0]:
                self.left_removed_count += 1
            else:
                self.right_removed_count += 1
            self.removed_pending[val] += 1
        
        self.rebalance()

    def clean(self):
        while self.left_heap and self.removed_pending[-self.left_heap[0]] > 0:
            self.removed_pending[-self.left_heap[0]] -= 1
            heapq.heappop(self.left_heap)
            self.left_removed_count -= 1

        while self.right_heap and self.removed_pending[self.right_heap[0]] > 0:
            self.removed_pending[self.right_heap[0]] -= 1
            heapq.heappop(self.right_heap)
            self.right_removed_count -= 1

    def rebalance(self):
        left_size = len(self.left_heap) - self.left_removed_count
        right_size = len(self.right_heap) - self.right_removed_count

        if left_size > 1 + right_size:
            heapq.heappush(self.right_heap, -heapq.heappop(self.left_heap))

        if left_size < right_size:
            heapq.heappush(self.left_heap, -heapq.heappop(self.right_heap))

        self.clean()

    def get_medium(self):
        left_size = len(self.left_heap) - self.left_removed_count
        right_size = len(self.right_heap) - self.right_removed_count

        if left_size == right_size:
            return (-self.left_heap[0] + self.right_heap[0]) / 2.0
        else:
            return float(-self.left_heap[0])
```
### Time complexity
* O(nlogn)
* worst case there are lots of pending delete item
### Space complexity
* O(n)
## Remark
* Need to clean after removal