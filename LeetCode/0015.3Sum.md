# 15. 3Sum

#### [link](https://leetcode.com/problems/3sum/)

#### Description
Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

#### Example 1:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```
#### Example 2:
```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```
#### Example 3:
```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

#### Constraints:
* `3 <= nums.length <= 3000`
* `-10^5 <= nums[i] <= 10^5`

## Two pointers
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        if(nums == null || nums.length < 3)
            return new ArrayList<>();
        
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        for(int i= 0 ; i < nums.length - 2 ; i++){
            if(i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            twoSum(nums, i + 1, nums.length - 1, -nums[i], ans);
        }
        
        return ans;
    }
    
    private void twoSum(int[] nums, int start, int end, int target, List<List<Integer>> ans){
        int leftMost = start;
        while(start < end){
            if(start > leftMost && nums[start] == nums[start - 1]){
                start++;
                continue;
            }
            if(end < nums.length - 1 && nums[end] == nums[end + 1]){
                end--;
                continue;
            }
            
            int sum = nums[start] + nums[end];
            if(sum > target){
                end--;
            }
            else if(sum < target){
                start++;
            }
            else{
                List<Integer> tmp = new ArrayList<>();
                ans.add(Arrays.asList(-target, nums[start], nums[end]));
                start++;
                end--;
            }
        }
    }
}
```
### Time complexity
* O(n^2), including sort(nlog(n))
### Space complexity
* O(1)
### Remark
* Use two pointer, hashset has advantage on not sorting, but duplicate array is far more easy if it is sorted.

## HashMap no sort (python)
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        num_count = {}
        distinct = set()
        for num in nums:
            num_count[num] = num_count.get(num, 0) + 1

        ans = []
        # all different
        distinct = list(num_count.keys())
        for i in range(len(distinct)):
            seen = set()
            for j in range(i + 1, len(distinct)):
                a, b = distinct[i], distinct[j]
                target = -(a + b)
                if target != a and target != b and target in seen:
                    ans.append([a, b, target])
                seen.add(distinct[j])

        # 2 same
        for num, count in num_count.items():
            if num != 0 and count >= 2 and -2 * num in num_count:
                ans.append([num, num, -2 * num])

        # 3 same
        if 0 in num_count and num_count[0] >= 3:
            ans.append([0, 0, 0])

        return ans
```
### Time complexity
* O(n^2)
### Space complexity
* O(n)
### Remark
* count elements and 3 different cases

## Sort + Two Pointers (python)
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()

        ans = []
        last = -10001
        i = 0
        while i < n:
            if nums[i] > 0:
                break
            if nums[i] != last:
                self.twoSum(i + 1, nums, -nums[i], ans)
                last = nums[i]
            i += 1
        return ans

    def twoSum(self, start, nums, target, ans):
        left, right = start, len(nums) - 1
        last_left, last_right = -100001, 100001
        while left < right:
            if nums[left] == last_left:
                left += 1
            elif nums[right] == last_right:
                right -= 1
            elif nums[left] + nums[right] > target:
                last_right = nums[right]
                right -= 1
            elif nums[left] + nums[right] < target:
                last_left = nums[left]
                left += 1
            else:
                ans.append([-target, nums[left], nums[right]])
                last_left = nums[left]
                last_right = nums[right]
                left += 1
                right -= 1
```
### Time complexity
* O(n^2), including sort(nlog(n))
### Space complexity
* O(1)
### Remark
* if nums[i] > 0, break

## Sort + HashSet
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()

        ans = []
        last = -10001
        i = 0
        while i < n:
            if nums[i] > 0:
                break
            if nums[i] != last:
                self.twoSum(i + 1, nums, -nums[i], ans)
                last = nums[i]
            i += 1
        return ans

    def twoSum(self, start, nums, target, ans):
        seen = set()
        i = start
        last = -10001
        while i < len(nums):
            if nums[i] != last:
                if target == 2 * nums[i] and i + 1 < len(nums) and nums[i] == nums[i + 1]:
                    ans.append([-target, nums[i], nums[i]])
                elif target - nums[i] in seen:
                    ans.append([-target, nums[i], target - nums[i]])
                seen.add(nums[i])
                last = nums[i]
            i += 1
```
### Time complexity
* O(n^2), including sort(nlog(n))
### Space complexity
* O(n)
### Remark
* Need to deal with duplicate scenario