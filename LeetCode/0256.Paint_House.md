# 256. Paint House

#### [link](https://leetcode.com/problems/paint-house/)

#### Description
There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.

* For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...

Return *the minimum cost to paint all houses.*

#### Example 1:
```
Input: costs = [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.
Minimum cost: 2 + 5 + 3 = 10.
```
#### Example 2:
```
Input: costs = [[7,6,2]]
Output: 2
```

#### Constraints:
* `costs.length == n`
* `costs[i].length == 3`
* `1 <= n <= 100`
* `1 <= costs[i][j] <= 20`

## DFS + Memo
```python
class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        memo = [[-1 for _ in range(3)] for _ in range(len(costs))]
        return min(self.cal(costs, 0, 0, memo), self.cal(costs, 0, 1, memo), self.cal(costs, 0, 2, memo))

    def cal(self, costs, now, now_color, memo):
        if now == len(costs):
            return 0
        
        if memo[now][now_color] != -1:
            return memo[now][now_color]

        min_cost = sys.maxsize
        for next_color in range(3):
            if next_color == now_color:
                continue
            min_cost = min(min_cost, costs[now][now_color] + self.cal(costs, now + 1, next_color, memo))

        memo[now][now_color] = min_cost
        return min_cost
```
### Time complexity
* O(n)
### Space complexity
* O(n)
### Remark

## Dynamic Programming
```python
class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        n = len(costs)
        dp = [[sys.maxsize for _ in range(3)] for _ in range(n + 1)]
        dp[n][0] = dp[n][1] = dp[n][2] = 0

        for i in range(n - 1, -1, -1):
            for color in range(3):
                for next_color in range(3):
                    if next_color == color:
                        continue
                    dp[i][color] = min(dp[i][color], costs[i][color] + dp[i + 1][next_color])

        return min(dp[0][0], dp[0][1], dp[0][2])
```
### Time complexity
* O(n)
### Space complexity
* O(n)
### Remark

## Dynamic Programming (optimized)
```python
class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        n = len(costs)
        now = [0] * 3

        for i in range(n - 1, -1, -1):
            prev = [sys.maxsize] * 3
            for color in range(3):
                for next_color in range(3):
                    if next_color == color:
                        continue
                    prev[color] = min(prev[color], costs[i][color] + now[next_color])
            now = prev

        return min(now)
```
### Time complexity
* O(n)
### Space complexity
* O(1)
### Remark