# 49. Group Anagrams

#### [link](https://leetcode.com/problems/group-anagrams/)

#### Description
Given an array of strings `strs`, group the **anagrams** together. You can return the answer in **any order**.

#### Example 1:
```
Input: strs = ["eat","tea","tan","ate","nat","bat"]

Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

Explanation:

- There is no string in strs that can be rearranged to form "bat".
- The strings "nat" and "tan" are anagrams as they can be rearranged to form each other.
- The strings "ate", "eat", and "tea" are anagrams as they can be rearranged to form each other.
```
#### Example 2:
```
Input: strs = [""]

Output: [[""]]
```
#### Example 3:
```
Input: strs = ["a"]

Output: [["a"]]
```

#### Constraints:
* `1 <= strs.length <= 10^4`
* `0 <= strs[i].length <= 100`
* `strs[i]` consists of lowercase English letters.

## HashMap
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> patternToList = new HashMap<>();
        for(String str : strs){
            //String pattern = getCount(str);
            String pattern = countingSort(str);
            if(!patternToList.containsKey(pattern)){
                patternToList.put(pattern, new ArrayList<>());
            }
            patternToList.get(pattern).add(str);
        }
        return new ArrayList<>(patternToList.values());
    }
    
    private String getCount(String s){
        int[] counts = new int[26];
        StringBuilder sb = new StringBuilder();
        for(char c : s.toCharArray()){
            counts[c - 'a']++;
        }
        for(int i = 0 ; i < counts.length ; i++){
            sb.append(counts[i]);
            sb.append('#');
        }
        return sb.toString();
    }
    
    private String countingSort(String s){
        int[] counts = new int[26];
        StringBuilder sb = new StringBuilder();
        for(char c : s.toCharArray()){
            counts[c - 'a']++;
        }
        for(int i = 0 ; i < counts.length ; i++){
            for(int j = 0 ; j < counts[i] ; j++){
                sb.append(i + 'a');
            }
        }
        return sb.toString();
    }
}
```
### Time complexity
* getCount: O(n * ((m + 26) + 52)) = O(nm)
* countingSort: O(n * ((m + 26) + m)) = O(nm)
* n: num of words, m: len of word
### Space complexity
* O(n)
### Remark
* getCount: fix key length: 52
* countingSort: key length is the same as original string

## Sort + HashMap (python)
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = {}
        for str in strs:
            sorted_str = "".join(sorted(str))
            if sorted_str not in groups:
                groups[sorted_str] = []
            groups[sorted_str].append(str)

        return list(groups.values())
```
### Time complexity
* m: number of strs
* n: length of str
* O(m * nlogn)
### Space complexity
* O(mn)
* key of hashmap
### Remark
* sorted() will return a list, not a string

## CountingSort + HashMap (python)
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = {}
        for s in strs:
            key = self.__counting_sort(s)
            if key not in groups:
                groups[key] = []
            groups[key].append(s)

        return list(groups.values())
    
    def __counting_sort(self, s):
        counts = [0] * 26
        for c in s:
            counts[ord(c) - ord("a")] += 1
        return "#".join([str(c) for c in counts])
```
### Time complexity
* m: number of strs
* n: length of str
* O(m * n)
### Space complexity
* O(m), as key length is fixed
### Remark
* sorted() will return a list, not a string