# 210. Course Schedule II

#### [link](https://leetcode.com/problems/course-schedule-ii/)

#### Description
There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return *the ordering of courses you should take to finish all courses.* If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.

#### Example 1:
```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
```
#### Example 2:
```
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
```
#### Example 3:
```
Input: numCourses = 1, prerequisites = []
Output: [0]
```

#### Constraints:
* `1 <= numCourses <= 2000`
* `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
* `prerequisites[i].length == 2`
* `0 <= ai, bi < numCourses`
* `ai != bi`
* All the pairs `[ai, bi]` are **distinct**.

## BFS (Topological Sort)
```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Node[] graph = new Node[numCourses];
        Deque<Node> queue = new ArrayDeque<>();
        int count = 0;
        int[] ans = new int[numCourses];
        
        for(int i = 0 ; i < graph.length ; i++){
            graph[i] = new Node(i);
        }
        for(int[] prereq : prerequisites){
            int a = prereq[1];
            int b = prereq[0];
            graph[a].next.add(graph[b]);
            graph[b].inDegree++;
        }
        for(Node now : graph){
            if(now.inDegree == 0)
                queue.addLast(now);
        }
        while(!queue.isEmpty()){
            Node now = queue.removeFirst();
            ans[count++] = now.val;
            for(Node next : now.next){
                next.inDegree--;
                if(next.inDegree == 0)
                    queue.addLast(next);
            }
        }
        return count == numCourses ? ans : new int[0];
    }
    
    private class Node{
        public int val;
        public int inDegree;
        public List<Node> next;
        
        public Node(int val){
            this.val = val;
            this.inDegree = 0;
            this.next = new ArrayList<>();
        }
    }
}
```
### Time complexity
* O(n + m)
* n : numOfCourses
* m : prerequisites.length
### Space complexity
* O(n)
### Remark

## Topological Sort (Python)
```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(numCourses)]
        in_degree = [0] * numCourses
        for a, b in prerequisites:
            graph[b].append(a)
            in_degree[a] += 1

        queue = deque()
        for i in range(numCourses):
            if(in_degree[i] == 0):
                queue.append(i)
        
        ans = []
        while queue:
            now = queue.popleft()
            ans.append(now)
            for next in graph[now]:
                in_degree[next] -= 1
                if in_degree[next] == 0:
                    queue.append(next)

        return ans if len(ans) == numCourses else []
```
### Time complexity
* O(V + E)
### Space complexity
* O(V)

## DFS (python)
```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(numCourses)]
        for a, b in prerequisites:
            graph[b].append(a)

        status = [0] * numCourses # 0 not visited, 1 current dfs, 2 visited 
        ans = []
        self.cycle = False
        for i in range(numCourses):
            if status[i] == 0:
                self.__dfs(i, status, graph, ans)
                if self.cycle:
                    return []

        return ans[::-1]

    def __dfs(self, now, status, graph, ans):
        if self.cycle:
            return

        status[now] = 1
        for next in graph[now]:
            # Cycle
            if status[next] == 1:
                self.cycle = True
                return
            elif status[next] == 0:
                self.__dfs(next, status, graph, ans)

        status[now] = 2
        ans.append(now)
```
### Time complexity
* O(V + E)
### Space complexity
* O(V)
### Remark
* append childs then parents, and reverse the answer