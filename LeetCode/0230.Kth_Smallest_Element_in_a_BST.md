# 230. Kth Smallest Element in a BST

#### [link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) 

#### Description
Given the `root` of a binary search tree, and an integer `k`, return *the `kth` smallest value (**1-indexed**) of all the values of the nodes in the tree*.

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)
```
Input: root = [3,1,4,null,2], k = 1
Output: 1
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)
```
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
```

#### Constraints:
* The number of nodes in the tree is 1.
* `1 <= k <= n <= 10^4`
* `0 <= Node.val <= 10^4`
 

#### Follow up:
If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?

Ans: 
* record number of left/right nodes for each node, so that each query only needs O(H) to find the kth smallest element

## DFS
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> array = new ArrayList<>();
        dfs(root, array);
        return array.get(k - 1);
    }
    
    private void dfs(TreeNode root, List<Integer> array){
        if(root == null)
            return;
        dfs(root.left, array);
        array.add(root.val);
        dfs(root.right, array);
    }
}
```
### Time complexity
* O(n)
### Space complexity
* O(n)
### Remark
* Flatten the binary tree by inorder

## Stack
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode now = root;
        int idx = 1;
        while(!stack.isEmpty() || now != null){
            while(now != null){
                stack.addFirst(now);
                now = now.left;
            }
            now = stack.removeFirst();
            if(idx == k)
                return now.val;
            idx++;
            now = now.right;
        }
        return -1;
    }
}
```
### Time complexity
* O(H + k), H: height
### Space complexity
* O(H + k)
### Remark
* Faster, don't have to save all the tree.

## Save number of nodes
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Map<TreeNode, Integer> nodeToCount = new HashMap<>();
        count(root, nodeToCount);
        return find(root, k, nodeToCount);
    }
    
    private int count(TreeNode root, Map<TreeNode, Integer> nodeToCount){
        if(root == null)
            return 0;
        
        int leftCount = count(root.left, nodeToCount);
        int rightCount = count(root.right, nodeToCount);
        int sum = 1 + leftCount + rightCount;
        nodeToCount.put(root, sum);
        
        return sum;
    }
    
    private int find(TreeNode root, int k, Map<TreeNode, Integer> nodeToCount) {
        if(root == null)
            return -1;
            
        int leftCount = root.left == null ? 0 : nodeToCount.get(root.left);
        if(k <= leftCount)
            return find(root.left, k, nodeToCount);
        if(k == leftCount + 1)
            return root.val;
        else
            return find(root.right, k - (leftCount + 1), nodeToCount);
    }
}
```
### Time complexity
* O(H + k), H: height
### Space complexity
* O(H + k)
### Remark
* Suitable for multiple quaries

## DFS inorder iteration (python)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        now = root
        count = 1
        while now or stack:
            while now:
                stack.append(now)
                now = now.left
            now = stack.pop()
            if count == k:
                return now.val
            count += 1
            now = now.right

        return -1
```
### Time complexity
* O(H + k), H: height
* H for pushing nodes to stack
* k for iteration
### Space complexity
* O(H)

## Count left and right child nodes (python)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.node_count = {}
        self.__dfs_count(root)
        return self.__dfs_find(root, k)

    def __dfs_count(self, now):
        if not now:
            return 0

        left_count = self.__dfs_count(now.left)
        right_count = self.__dfs_count(now.right)
        
        self.node_count[now] = (left_count, right_count)
        return 1 + left_count + right_count

    def __dfs_find(self, now, k):
        left_count, right_count = self.node_count[now]
        if k <= left_count:
            return self.__dfs_find(now.left, k)
        elif k == left_count + 1:
            return now.val
        else:
            return self.__dfs_find(now.right, k - left_count - 1)
```
### Time complexity
* O(N), N: number of nodes
### Space complexity
* O(N)
### Remark
* Suitable for multiple quaries
* Each find only takes O(H)