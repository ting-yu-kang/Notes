# 269. Alien Dictionary

## Also
[Leetcode 892](../LintCode/892.Alien_Dictionary.md)

#### [link](https://leetcode.com/problems/alien-dictionary/)

#### Description
There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.

You are given a list of strings `words` from the alien language's dictionary. Now it is claimed that the strings in `words` are **sorted lexicographically** by the rules of this new language.

If this claim is incorrect, and the given arrangement of string in `words` cannot correspond to any order of letters, return `""`.

Otherwise, return *a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules*. If there are multiple solutions, return ***any of them***.

#### Example 1:
```
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"
```
#### Example 2:
```
Input: words = ["z","x"]
Output: "zx"
```
#### Example 3:
```
Input: words = ["z","x","z"]
Output: ""
Explanation: The order is invalid, so return "".
```

#### Constraints:
* `1 <= words.length <= 100`
* `1 <= words[i].length <= 100`
* `words[i]` consists of only lowercase English letters.

## BFS (Topological Sorting)
```java
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, Set<Character>> graph = new HashMap<>();
        Map<Character, Integer> indegrees = new HashMap<>();
        Deque<Character> queue = new ArrayDeque<>();
        StringBuilder sb = new StringBuilder();
        for(String word : words){
            for(char c : word.toCharArray()){
                graph.putIfAbsent(c, new HashSet<>());
            }
        }
        for(int i = 0 ; i < words.length - 1 ; i++){
            String a = words[i];
            String b = words[i + 1];
            int j = 0;
            while(j < a.length() && j < b.length()){
                if(a.charAt(j) != b.charAt(j)){
                    graph.get(a.charAt(j)).add(b.charAt(j));
                    break;
                }
                j++;
            }
        }
        for(Set<Character> edgeTo : graph.values()){
            for(char c : edgeTo){
                indegrees.compute(c, (k, v) -> v == null ? 1 : v + 1);
            }
        }
        for(char c : graph.keySet()){
            if(!indegrees.containsKey(c))
                queue.addLast(c);
        }
        while(!queue.isEmpty()){
            char now = queue.removeFirst();
            sb.append(now);
            for(char next : graph.get(now)){
                indegrees.compute(next, (k, v) -> v - 1);
                if(indegrees.get(next) == 0){
                    queue.addLast(next);
                }
            }
        }
        return sb.length() == graph.size() ? sb.toString() : "";
    }
}
```
### Time complexity
* O(m * n)
* m : number of words
* n : word length
### Space complexity
* O(m * n)
### Remark

## Topological Sort (python)
```python
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        graph = {}
        in_degree = {}
        
        # go through all characters
        for word in words:
            for c in word:
                if c not in in_degree:
                    in_degree[c] = 0
                if c not in graph:
                    graph[c] = []

        # build graph
        for word_a, word_b in zip(words, words[1:]):
            if word_a != word_b and word_a.startswith(word_b):
                return ""
            for a, b in zip(word_a, word_b):
                if a != b:
                    graph[a].append(b)
                    in_degree[b] += 1
                    break

        # topological sort
        queue = deque()
        for c, indeg in in_degree.items():
            if indeg == 0:
                queue.append(c)

        ans = []
        while queue:
            now = queue.popleft()
            ans.append(now)
            for next in graph[now]:
                in_degree[next] -= 1
                if in_degree[next] == 0:
                    queue.append(next)

        if len(ans) != len(graph):
            return ""

        return "".join(ans)
```
### Time complexity
* O(m * n)
* m : number of words
* n : word length
### Space complexity
* O(m * n)
### Remark