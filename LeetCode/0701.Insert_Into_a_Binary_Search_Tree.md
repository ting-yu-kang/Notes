# 701. Insert into a Binary Search Tree

#### [link](https://leetcode.com/problems/insert-into-a-binary-search-tree/) 

#### Description
You are given the `root` node of a binary search tree (BST) and a `value` to insert into the tree. Return *the root node of the BST after the insertion.* It is **guaranteed** that the new value does not exist in the original BST.

**Notice** that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return **any of them**.

#### Example 1:
![](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)
```
Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:
```
![](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)
#### Example 2:
```
Input: root = [40,20,60,10,30,50,70], val = 25
Output: [40,20,60,10,30,50,70,null,null,25]
```
#### Example 3:
```
Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
Output: [4,2,7,1,3,5]
```

#### Constraints:
* The number of nodes in the tree will be in the range `[0, 10^4]`.
* `-10^8 <= Node.val <= 10^8`
* All the values `Node.val` are **unique**.
* `-10^8 <= val <= 10^8`
* It's **guaranteed** that `val` does not exist in the original BST.

## Iteration
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        TreeNode now = root;
        while(now != null){
            if(val > now.val){
                if(now.right == null){
                    now.right = new TreeNode(val);
                    return root;
                }
                now = now.right;
            }
            else if(val < now.val){
                if(now.left == null){
                    now.left = new TreeNode(val);
                    return root;
                }
                now = now.left;
            }
            else{
                throw new IllegalArgumentException();
            }
        }
        
        return new TreeNode(val);
    }
}
```

### Time complexity
* O(H), H: tree height
### Space complexity
* O(1)
### Remark

## Recursion
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null)
            return new TreeNode(val);
        if(val > root.val)
            root.right = insertIntoBST(root.right, val);
        else if(val < root.val)
            root.left = insertIntoBST(root.left, val);
        else
            throw new IllegalArgumentException();
        return root;
    }
}
```
### Time complexity
* O(H), H: tree height
### Space complexity
* O(H)
### Remark

## Recursion (python)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)

        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        else:
            root.right = self.insertIntoBST(root.right, val)

        return root
```
### Time complexity
* O(H), H: tree height
### Space complexity
* O(H)
### Remark