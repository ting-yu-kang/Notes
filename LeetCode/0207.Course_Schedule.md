# 207. Course Schedule

#### [link](https://leetcode.com/problems/course-schedule/)

#### Description
There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return `true` if you can finish all courses. Otherwise, return `false`.

#### Example 1:
```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
```
#### Example 2:
```
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
```

#### Constraints:
* `1 <= numCourses <= 2000`
* `0 <= prerequisites.length <= 5000`
* `prerequisites[i].length == 2`
* `0 <= ai, bi < numCourses`
* All the pairs prerequisites[i] are **unique**.


## BFS (Topological Sort)
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Node[] graph = new Node[numCourses];
        Deque<Node> queue = new ArrayDeque<>();
        int count = 0;
        for(int i = 0 ; i < graph.length ; i++){
            graph[i] = new Node();
        }
        for(int[] prereq : prerequisites){
            int a = prereq[1];
            int b = prereq[0];
            graph[a].next.add(graph[b]);
            graph[b].inDegree++;
        }
        for(Node now : graph){
            if(now.inDegree == 0)
                queue.addLast(now);
        }
        while(!queue.isEmpty()){
            Node now = queue.removeFirst();
            count++;
            for(Node next : now.next){
                next.inDegree--;
                if(next.inDegree == 0)
                    queue.addLast(next);
            }
        }
        return count == numCourses;
    }
    
    private class Node{
        public int inDegree;
        public List<Node> next;
        
        public Node(){
            this.inDegree = 0;
            this.next = new ArrayList<>();
        }
    }
}
```
### Time complexity
* O(n + m)
* n : numOfCourses
* m : prerequisites.length
### Space complexity
* O(n)
### Remark

## BFS Topological Sort (python)
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        in_degree = [0] * numCourses
        for a, b in prerequisites:
            graph[b].append(a)
            in_degree[a] += 1

        queue = deque()
        for i in range(numCourses):
            if in_degree[i] == 0:
                queue.append(i)

        course_count = 0
        while queue:
            now = queue.popleft()
            course_count += 1
            for next in graph[now]:
                in_degree[next] -= 1
                if in_degree[next] == 0:
                    queue.append(next)
        
        return course_count == numCourses
```
### Time complexity
* O(n + m)
* n : numOfCourses
* m : prerequisites.length
### Space complexity
* O(n + m), graph
### Remark
* no need to have visit array, as any node in queue has 0 in degree and will not be visited again.

## DFS (python)
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        for a, b in prerequisites:
            graph[b].append(a)
        
        self.visited = set()
        for i in range(numCourses):
            if self.__has_cycle(i, graph, set()):
                return False

        return True
        
    def __has_cycle(self, now, graph, now_path):
        if now in now_path:
            return True
        if now in self.visited:
            return False

        now_path.add(now)
        self.visited.add(now)
        for next in graph[now]:
            if self.__has_cycle(next, graph, now_path):
                return True
        now_path.remove(now)
        return False
```
### Time complexity
* O(n + m)
* n : numOfCourses
* m : prerequisites.length
### Space complexity
* O(n + m), graph
### Remark
* A little bit tricky on visited array.
* If the current path is reached twice, there is a cycle.
* If it's already visited, it means it doesn't have cycle.