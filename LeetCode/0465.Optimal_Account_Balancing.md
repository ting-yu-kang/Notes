# 465. Optimal Account Balancing

#### [link](https://leetcode.com/problems/optimal-account-balancing/)

#### Description
You are given an array of transactions `transactions` where `transactions[i] = [fromi, toi, amounti]` indicates that the person with `ID = fromi` gave `amounti $` to the person with `ID = toi`.

Return *the minimum number of transactions required to settle the debt*.

#### Example 1:
```
Input: transactions = [[0,1,10],[2,0,5]]
Output: 2
Explanation:
Person #0 gave person #1 $10.
Person #2 gave person #0 $5.
Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.
```
#### Example 2:
```
Input: transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]
Output: 1
Explanation:
Person #0 gave person #1 $10.
Person #1 gave person #0 $1.
Person #1 gave person #2 $5.
Person #2 gave person #0 $5.
Therefore, person #1 only need to give person #0 $4, and all debt is settled.
```

#### Constraints:
* `1 <= transactions.length <= 8`
* `transactions[i].length == 3`
* `0 <= fromi, toi < 12`
* `fromi != toi`
* `1 <= amounti <= 100`

## BackTracking (TLE)
```python
class Solution:
    def minTransfers(self, transactions: List[List[int]]) -> int:
        balances = [0] * 12
        for _from, _to, amount in transactions:
            balances[_from] -= amount
            balances[_to] += amount

        return self._min_step(0, balances)

    def _min_step(self, now, balances):
        if now == len(balances):
            return 0

        if balances[now] == 0:
            return self._min_step(now + 1, balances)

        min_step = sys.maxsize
        for next in range(now + 1, len(balances)):
            if balances[now] * balances[next] > 0:
                continue
            balances[next] += balances[now]
            min_step = min(min_step, 1 + self._min_step(now + 1, balances))
            balances[next] -= balances[now] 

        return min_step
```
### Time complexity
* O(n!)
### Space complexity
* O(n)
### Remark
* Try every possible way to transfer money

## Dynamic Programming with BitMap
```python
class Solution:
    def minTransfers(self, transactions: List[List[int]]) -> int:
        balances_all = [0] * 12
        for _from, _to, amount in transactions:
            balances_all[_from] -= amount
            balances_all[_to] += amount

        balances = []
        for balance in balances_all:
            if balance != 0:
                balances.append(balance)

        n = len(balances)
        return n - self._zero_groups((1 << n) - 1, balances, [-1] * (1 << n))

    def _zero_groups(self, bit_map, balances, memo):
        if bit_map == 0:
            return 0

        if memo[bit_map] != -1:
            return memo[bit_map]

        n = len(balances)
        sum = 0
        subgroups = 0
        for i in range(n):
            mask = 1 << i
            if bit_map & mask:
                sum += balances[i]
                subgroups = max(subgroups, self._zero_groups(bit_map ^ mask, balances, memo))

        if sum == 0:
            memo[bit_map] = subgroups + 1
        else:
            memo[bit_map] = subgroups

        return memo[bit_map]     
```
### Time complexity
* O(n * 2^n)
### Space complexity
* O(2^n)
### Remark
* calculate how many zero subgroups in a given bit_map
* If sum is zero, max_subgroup + 1
* Otherwise, max_subgroup