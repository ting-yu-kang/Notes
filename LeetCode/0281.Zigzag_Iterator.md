# 281. Zigzag Iterator

#### [link](https://leetcode.com/problems/zigzag-iterator/) 

#### Description
Given two vectors of integers `v1` and `v2`, implement an iterator to return their elements alternately.

Implement the `ZigzagIterator` class:

* `ZigzagIterator(List<int> v1, List<int> v2)` initializes the object with the two vectors v1 and v2.
* `boolean hasNext()` returns `true` if the iterator still has elements, and `false` otherwise.
* `int next()` returns the current element of the iterator and moves the iterator to the next element.

#### Example 1:
```
Input: v1 = [1,2], v2 = [3,4,5,6]
Output: [1,3,2,4,5,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].
```
#### Example 2:
```
Input: v1 = [1], v2 = []
Output: [1]
```
#### Example 3:
```
Input: v1 = [], v2 = [1]
Output: [1]
```

### Constraints:
* `0 <= v1.length, v2.length <= 1000`
* `1 <= v1.length + v2.length <= 2000`
* `-2^31 <= v1[i], v2[i] <= 2^31 - 1`

**Follow up:** What if you are given k vectors? How well can your code be extended to such cases?

**Clarification for the follow-up question:**

The "Zigzag" order is not clearly defined and is ambiguous for `k > 2` cases. If "Zigzag" does not look right to you, replace "Zigzag" with "Cyclic".

### Follow-up Example:
Input: v1 = [1,2,3], v2 = [4,5,6,7], v3 = [8,9]
Output: [1,4,8,2,5,9,3,6,7]

## mod
```java
public class ZigzagIterator {
    int[] indices;
    List<List<Integer>> lists;
    int iter;
    
    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        iter = 0;
        lists = new ArrayList<>();
        lists.add(v1);
        lists.add(v2);
        indices = new int[lists.size()];
    }

    public int next() {
        int val = 0;
        for(int i = 0 ; i < lists.size() ; i++, iter++){
            int now = iter % lists.size();
            if(indices[now] < lists.get(now).size()){
                val = lists.get(now).get(indices[now]);
                iter++;
                indices[now]++;
                break;
            }
        }
        return val;
    }

    public boolean hasNext() {
        for(int i = 0 ; i < lists.size() ; i++){
            int now = (iter + i) % lists.size();
            if(indices[now] < lists.get(now).size()){
                return true;
            }
        }
        return false;
    }
}

/**
 * Your ZigzagIterator object will be instantiated and called as such:
 * ZigzagIterator i = new ZigzagIterator(v1, v2);
 * while (i.hasNext()) v[f()] = i.next();
 */
```

### Time complexity
* O()
### Space complexity
* O(1)
### Remark

## Deque
```java
public class ZigzagIterator {
    Deque<int[]> iterators;
    List<Integer> v1;
    List<Integer> v2;
    
    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        iterators = new ArrayDeque<>();
        this.v1 = v1;
        this.v2 = v2;
        if(v1.size() > 0)
            iterators.addLast(new int[]{1, 0});
        if(v2.size() > 0)
            iterators.addLast(new int[]{2, 0});
    }

    public int next() {
        int[] now = iterators.removeFirst();
        int val = 0;
        if(now[0] == 1){
            val = v1.get(now[1]++);
            if(now[1] < v1.size()){
                iterators.addLast(now);
            }
        }
        else{
            val = v2.get(now[1]++);
            if(now[1] < v2.size()){
                iterators.addLast(now);
            }
        }
        return val;
    }

    public boolean hasNext() {
        return !iterators.isEmpty();
    }
}

/**
 * Your ZigzagIterator object will be instantiated and called as such:
 * ZigzagIterator i = new ZigzagIterator(v1, v2);
 * while (i.hasNext()) v[f()] = i.next();
 */
 ```
### Time complexity
* O()
### Space complexity
* O(1)
### Remark

## Iterator
```java
public class ZigzagIterator {
    Deque<Iterator> iterators;
    
    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        iterators = new ArrayDeque<>();
        if(v1.size() > 0)
            iterators.addLast(v1.iterator());
        if(v2.size() > 0)
            iterators.addLast(v2.iterator());
    }

    public int next() {
        Iterator<Integer> now = iterators.removeFirst();
        int val = now.next();
        if(now.hasNext())
            iterators.addLast(now);
        return val;
    }

    public boolean hasNext() {
        return !iterators.isEmpty();
    }
}

/**
 * Your ZigzagIterator object will be instantiated and called as such:
 * ZigzagIterator i = new ZigzagIterator(v1, v2);
 * while (i.hasNext()) v[f()] = i.next();
 */
 ```
### Time complexity
* O()
### Space complexity
* O(1)
### Remark

## Two Pointers
```python
class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.v1 = v1
        self.v2 = v2
        self.now1 = 0
        self.now2 = 0
        self.turn = 0

    def next(self) -> int:
        if self.now1 == len(self.v1):
            val = self.v2[self.now2]
            self.now2 += 1
            return val
        elif self.now2 == len(self.v2):
            val = self.v1[self.now1]
            self.now1 += 1
            return val
        else:
            if self.turn == 0:
                val = self.v1[self.now1]
                self.now1 += 1
            else:
                val = self.v2[self.now2]
                self.now2 += 1
            self.turn = (self.turn + 1) % 2
            return val

    def hasNext(self) -> bool:
        return self.now1 < len(self.v1) or self.now2 < len(self.v2)

# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())
```
### Time complexity
* O(2)
* each time we need to check each array 
### Space complexity
* O(1)
### Remark

## Queue
```python
class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.vectors = [v1, v2]
        self.queue = deque()
        for v_id in range(len(self.vectors)):
            if len(self.vectors[v_id]) == 0:
                continue
            self.queue.append((v_id, 0, self.vectors[v_id][0]))

    def next(self) -> int:
        v_id, i, now = self.queue.popleft()
        if i + 1 < len(self.vectors[v_id]):
            self.queue.append((v_id, i + 1, self.vectors[v_id][i + 1]))
        return now

    def hasNext(self) -> bool:
        return self.queue

# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())
```
### Time complexity
* O(1)
### Space complexity
* O(m)
* track each queue's current element
### Remark
* good for multiple vectors