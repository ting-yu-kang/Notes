# 261. Graph Valid Tree

#### [link](https://leetcode.com/problems/graph-valid-tree/)

#### Description
You have a graph of n nodes labeled from `0` to `n - 1`. You are given an integer n and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.

Return `true` if *the edges of the given graph make up a valid tree, and* `false` *otherwise*.

#### Example 1:
![](https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg)
```
Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true
```
#### Example 2:
![](https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg)
```
Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false
```

#### Constraints:
* `1 <= n <= 2000`
* `0 <= edges.length <= 5000`
* `edges[i].length == 2`
* `0 <= ai, bi < n`
* `ai != bi`
* There are no self-loops or repeated edges.

## BFS
```java
class Solution {
    public boolean validTree(int n, int[][] edges) {
        if(edges.length != n - 1)
            return false;
        
        boolean[] visit = new boolean[n];
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        Deque<Integer> queue = new ArrayDeque<>();
        int count = 0;
        for(int i = 0 ; i < n ; i++){
            graph.put(i, new HashSet<>());
        }
        for(int[] edge : edges){
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        queue.addLast(0);
        visit[0] = true;
        while(!queue.isEmpty()){
            int now = queue.removeFirst();
            count++;
            for(int next : graph.get(now)){
                if(visit[next])
                    continue;
                visit[next] = true;
                queue.add(next);
            }
        }
        
        return count == n;
    }
}
```
### Time complexity
* O(n + edges) = O(n)
### Space complexity
* O(n + edges) = O(n)
### Remark 
1. number of edges = number of nodes - 1
2. no cycle, fully connected

## Union Find
```java
class Solution {
    public boolean validTree(int n, int[][] edges) {
        if(edges.length != n - 1)
            return false;
        UnionFind UF = new UnionFind(n);
        for(int[] edge : edges){
            if(UF.find(edge[0]) == UF.find(edge[1]))
                return false;
            UF.union(edge[0], edge[1]);
        }
        
        return true;
    }
    
    private class UnionFind{
        int[] parent;
        int[] rank;
        
        public UnionFind(int n){
            this.parent = new int[n]; 
            this.rank = new int[n];
            for(int i = 0 ; i < n ; i++){
                parent[i] = i;
            }
        }
        
        public int find(int now){
            if(parent[now] != now){
                parent[now] = find(parent[now]);
            }
            return parent[now];
        }
        
        public void union(int a, int b){
            int parentA = find(a);
            int parentB = find(b);
            
            if(parentA == parentB)
                return;
            
            if(rank[a] > rank[b])
                parent[parentB] = parentA;
            else if(rank[a] < rank[b])
                parent[parentA] = parentB;
            else{
                parent[parentA] = parentB;
                rank[b]++;
            }
        }
    }
}
```
### Time complexity
* O(ElogV) = O(nlogn)
### Space complexity
* O(n)
### Remark 
* Brilliant!
* every new added point must not be unioned before. Otherwise, there must be a cycle.

### DFS(python)
```python
class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != n - 1:
            return False

        graph = {}
        for a, b in edges:
            if a not in graph:
                graph[a] = []
            if b not in graph:
                graph[b] = []
            graph[a].append(b)
            graph[b].append(a)
            
        visited = set()
        self.__dfs(0, graph, visited)
        return len(visited) == n

    def __dfs(self, now, graph, visited):
        if now in visited:
            return
        visited.add(now)
        if now not in graph:
            return
        for next in graph[now]:
            self.__dfs(next, graph, visited)
```
### Time complexity
* O(n + edges) = O(n), since it's tree
### Space complexity
* O(n + edges) = O(n), graph
### Remark 
1. number of edges = number of nodes - 1
2. no cycle, fully connected

## Union Find(python)
```python
class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != n - 1:
            return False

        uf = UnionFind(n)
        for a, b in edges:
            if not uf.union(a, b):
                return False

        return True

class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.size = [1] * n

    def union(self, a, b):
        parent_a = self.find(a)
        parent_b = self.find(b)
        if parent_a == parent_b:
            return False

        if self.size[parent_a] < self.size[parent_b]:
            self.parent[parent_a] = parent_b
            self.size[parent_b] += self.size[parent_a]
        else:
            self.parent[parent_b] = parent_a
            self.size[parent_a] += self.size[parent_b]

        return True

    def find(self, a):
        if self.parent[a] != a:
            self.parent[a] = self.find(self.parent[a])

        return self.parent[a]
```
### Time complexity
* O(edges * alpha(n)) = O(n), since it's tree
### Space complexity
* O(n)